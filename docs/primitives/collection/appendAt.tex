\documentclass[../../main.tex]{subfiles}

\begin{document}

\subsubsection{Append At}
The Primitive $appendAt$ uses the Primitive $atDepth$ to navigated into a nested collection $coll?$ (called $coll$ bellow).
The Value $v?$ passed to $appendAt$ will be appended to $coll$ at $idxs?_{j}$. This results in a $coll!$ which
is equivalent to $coll?$ except for at the value at the path $idxs?_{i}~..~idxs?_{j} \in coll?$.
\begin{schema}{Append At[Collection, Collection, V]}
  AtDepth \\
  coll?, coll!, idxs? : Collection \\
  v? : V \\
  appendAt~\_ : Collection \cross Collection \cross V \bij Collection
  \where
  appendAt = \langle atDepth~\_~, append~\_~, \langle ~atDepth~\_~, remove~\_~, append~\_ \rangle \bsup \#~idxs? - 1 \esup \rangle \\
  coll! = appendAt(coll?, idxs?, v?) @ \\
  \t1 let \ \ ~~ coll == append(atDepth(coll?, idxs? ~\ndres ~ idxs?_{j}), v?, idxs?_{j}) @ \\
  \t2 \forall n : i~..~j-1 @ j = first(last(idxs?)) ~|~ \exists ~ c_{n} @ \\
  \t3 let \ \ ~~ c_{i} == atDepth(coll?, (idxs? \extract i)) \implies atIndex(coll?, idxs?_{i}) \\
  \t4 c_{n} == atDepth(c_{n-1}, (idxs? \extract n)) \\
  \t4 c_{j-1} == atDepth(c_{n}, (idxs? \extract j-1)) \iff n = j-2 \\
  \t4 c_{j} == append(c_{j-1}, v?, (idxs? \extract j)) \implies c_{j} = coll = coll!_{j}\\
  \t4 coll!_{j-1} == append(remove(c_{j-2}, idxs?_{j-1}), c_{j}, idxs?_{j-1}) \\
  \t4 coll!_{n} == append(remove(c_{n-1}, idxs?_{n}), coll!_{n+1}, idxs?_{n}) \\
  \t4 coll!_{i} == append(remove(c_{i}, idxs?_{n}), coll!_{n}, idxs?_{n}) \iff n = i + 1 \\
  \t1 = append(remove(coll?, idxs?_{i}), coll!_{i}, idxs?_{i})
\end{schema}
The relationship described above $coll? \ndres idxs_{i} = coll! \ndres idxs_{i}$ is described above
as $\langle ~atDepth~\_~, remove~\_~, append~\_ \rangle \bsup \#~idxs? - 1 \esup$. The variables
$coll!_{i~..~j}$ were used to describe the sub Collections which have to have a single
index updated given $idxs?$. Those subcollections are combined together to produce
$coll!$ such that the only difference between $coll? ~\land~ coll!$ is found at path $idxs?$
The following examples demonstrate the properties of $appendAt$ described above.

\begin{argue}
  X = \langle x_{0}, x_{1}, x_{2} \rangle \\
  \t1 x_{0} = 0 \\
  \t1 x_{1} = foo \\
  \t1 x_{2} = \langle a, b, c \rangle \\
  appendAt(X, \langle 1, 3 \rangle, z) = \langle x_{0}, fooz, x_{2} \rangle \implies foo = \langle f, o, o \rangle\\
  appendAt(X, \langle 1 \rangle, 5) = \langle \langle 0, 5 \rangle, x_{1}, x_{2} \rangle  & existing item gets 0 index \\
  appendAt(X, \langle 1, 0 \rangle, 5) = \langle \langle 5, 0 \rangle, x_{1}, x_{2} \rangle  & overwritting default behavior \\
  appendAt(X, \langle 2, 0 \rangle, d) = \langle x_{0}, x_{1}, \langle d, a, b, c \rangle \rangle \\
  appendAt(X, \langle 2 \rangle, d) = \langle x_{0}, x_{1}, \langle a, b, c, d \rangle \rangle \\
\end{argue}

\end{document}
