\documentclass[../main.tex]{subfiles}
\begin{document}

\section{Rate of Completions}
As learners engage in activities supported by a learning ecosystem, they will build
up a history of learning experiences. When the digital resources of that learning ecosystem
adhere to a framework dedicated to supporting and understanding the
learner, such as the Total Learning Architecture (TLA), it becomes
possible to retell their learning story through data and data visualization. One important aspect of
that story is the rate of completion of the various digital resources within the learning ecosystem.

\begin{schema}{RateOfCompletions[KV, Collection, KV]}
  Algorithm \\
  RateOfCompletionsInit \\
  RateOfCompletionsRelevant? \\
  RateOfCompletionsAccept? \\
  RateOfCompletionsStep \\
  RateOfCompletionsResult \\
  rateOfCompletions~\_ : KV \cross Collection \cross KV \surj KV \\
  state?, opt?, rateOfCompletions! : KV \\
  S? : Collection
  \where
  Algorithm.algorithm.algorithmIter = \langle relevant?~\_~, accept?~\_~, step~\_ \rangle \\
  ROCalgorithmIter = \langle RateOfCompletionsRelevant?.relevant?~\_~, \\
  \t5 \ RateOfCompletionsAccept?.accept?~\_~, \\
  \t5 \ RateOfCompletionsStep.step~\_ \rangle \\ ~ \\

  Algorithm.algorithm.algorithmIter~\_~ \bindsto ROCalgorithmIter~\_~ \implies \\
  \t1 (Algorithm.algorithm.algorithmIter.relevant?~\_ \bindsto \\
  \t3 RateOfCompletionsRelevant?.relevant?~\_)  ~\land \\
  \t1 (Algorithm.algorithm.algorithmIter.accept?~\_ \bindsto \\
  \t3 RateOfCompletionsAccept?.accept?~\_) ~\land \\
  \t1 (Algorithm.algorithm.algorithmIter.step~\_ \bindsto \\
  \t3 RateOfCompletionsStep.step~\_) \\ ~ \\

  rateOfCompletions! = rateOfCompletions(state?, S?, opt?) = algorithm(state?, S?, opt?) @ \\
  \t1 (Algorithm.algorithm.init~\_ \bindsto RateOfCompletionsInit.init~\_) ~\land \\
  \t1 (Algorithm.algorithm.algorithmIter~\_ \bindsto ROCalgorithmIter~\_) ~ \land \\
  \t1 (Algorithm.algorithm.result~\_ \bindsto RateOfCompletionsResult.result~\_)
\end{schema}
\begin{itemize}
\item FIXME: explain usage of $\bindsto$
\item FIXME: explan usage of $SchemaName.component.subcomponent$
\end{itemize}

\subsection{Initialization}
\begin{schema}{RateOfCompletionsInit[KV]}
  Init \\
  state?, state! : KV \\
  init~\_ : KV \surj KV
  \where
  Init.init = \langle body \rangle \\
  \langle body \rangle \bindsto init = \langle FIXME: ~what ~primitives ~are ~needed? \rangle \\
  state! = init(state?) @ FIXME: ~what ~happens?
\end{schema}
% check to see if \langle state, completions \rangle exists in passed in state
% - if its there, return state without alteration
% - if its not there, add it to the passed in state and return the result.

\subsection{Relevant?}
\begin{schema}{RateOfCompletionsRelevant?[KV, STATEMENT]}
  Relevant? \\
  state? : KV \\
  stmt? : STATEMENT \\
  relevant! : Boolean \\
  relevant?~\_ : KV \cross STATEMENT \fun Boolean
  \where
  Relevant.relevant? = \langle body \rangle \\
  \langle body \rangle \bindsto relevant? = \langle FIXME: ~what ~primitives ~are ~needed? \rangle \\
  relevant! = relevant?(state?, stmt?) @ FIXME: ~what ~happens?
\end{schema}
% WIP - bellow -> Z
$relevant?(state, stmt)$ determines if $stmt$ is valid for use within $step$ of $rateOfCompletions$ and does so by
looking into various $k \to v$ within $stmt$. The following Primitives are used as the $body$ of $relevant?(state, stmt)$
\begin{itemize}
\item is the Object of the Statement an Activity?
  $$activityType = atKey(stmt, <object, objectType>)$$
  $$activity?(activityType) = true \iff activityType = Activity \ \lor activityType = nil$$
\item is the Verb indicative of a completion event?
  $$verbId = atKey(stmt, <verb, id>)$$
  $$completionVerb?(verbId) = true$$
  $$\iff$$
  $$verbId = http://adlnet.gov/expapi/verbs/passed$$
  $$\lor$$
  $$verbId = https://w3id.org/xapi/dod-isd/verbs/answered$$
  $$\lor$$
  $$verbId = http://adlnet.gov/expapi/verbs/completed$$
\item does the $stmt$ indicate completion using Result?
  $$result = atKey(stmt, <result, completion>)$$
  $$resultCompletion = true \iff result = true$$
\end{itemize}
$\\$
such that the body of $relevant?$ contains
$$p_{a}(stmt) = activity?(atKey(stmt, <object, objectType>))$$
and
$$p_{v}(stmt) = completionVerb?(atKey(stmt, <verb, id>))$$
and
$$p_{r}(stmt) = resultCompletion(atKey(stmt, <result, completion>))$$
which are used to form higher level Primitives
$$p_{continue}(stmt) = stmt \iff p_{a}(stmt) = true$$
and
$$p_{completed?}(stmt) = stmt \iff p_{v}(stmt) = true \ \lor \ p_{r}(stmt) = true$$
which results in a final Primitive $p_{return?}$
$$p_{return?}(stmt) = object?(p_{completed?}(p_{continue}(stmt)))$$
which defines the $body$ of $relevant?$
$$relevant?(stmt) = p_{return?}(stmt) \implies object?(p_{completed?}(p_{continue}(stmt)))$$
and can be summarized as
$$relevant?(state, stmt) = true$$
$$\iff$$
$$activity?(activitType) = true$$
$$\land$$
$$completionVerb?(verbId) = true \ \lor \ resultCompletion = true$$

\subsection{Accept?}
\begin{schema}{RateOfCompletionsAccept?[KV, STATEMENT]}
  Accept? \\
  state? : KV \\
  stmt? : STATEMENT \\
  accept! : Boolean \\
  accept?~\_ : KV \cross STATEMENT \fun Boolean
  \where
  Accept?.accept? = \langle body \rangle \\
  \langle body \rangle \bindsto accept? = \langle FIXME: ~what ~primitives ~are ~needed? \rangle \\
  accept! = accept?(state?, stmt?) @ FIXME: ~what ~happens?
\end{schema}
% WIP - bellow -> Z
$rateOfCompletions$ does not require further boolean logic to determine if $stmt$ and $state$ can be passed to $step$
$$accept?(state, stmt) = object?(stmt)$$
which should always return true assuming valid xAPI Statements are passed to $rateOfCompletions$

\subsection{Step}
\begin{schema}{RateOfCompletionsStep[KV, STATEMENT]}
  Step \\
  state?, step! : KV \\
  stmt? : STATEMENT \\
  step~\_ : KV \cross STATEMENT \surj KV
  \where
  Step.step = \langle body \rangle \\
  \langle body \rangle \bindsto step = \langle FIXME: ~what ~primitives ~are ~needed? \rangle \\
  step! = step(state?, stmt?) @  FIXME: ~what ~happens?
\end{schema}
% WIP - bellow -> Z
\subsubsection{summary}
$step(state, stmt)$ updates $state$ to include
$$\$.object.id \mapsto <domain, statementCount, name>$$
where
$$domain \mapsto <start, end> $$
$$statementCount \mapsto \real$$
$$name \mapsto <\$.object.definition.name>$$
at
$$<state, completions, \$.object.id>$$

\subsubsection{processing}
$step$ starts by extracting the relevant information from $stmt$
\begin{itemize}
\item $currentTime$
  $$currentTime = atKey(stmt, timestamp)$$
\item $name$
  $$name_{stmt} = atKey(stmt, <object, definition, name>)$$
\item $objectId$
  $$objectId = atKey(stmt, <object, id>)$$
\end{itemize}
which allows for the previous $state$ to be resolved using $objectId$
\begin{itemize}
\item $domain$
  $$domain_{state} = atKey(state, <state, completions, objectId, domain>)$$
  $$start_{state} = first(domain_{state})$$
  $$end_{state} = last(domain_{state})$$
\item $statementCount$
  $$statementCount_{state} = atKey(state, <state, completions, objectId, statementCount>)$$
\item $name$
  $$name_{state} = atKey(state, <state, completions, objectId, name>)$$
\end{itemize}
so that the previous state can be used along side the information parsed from $stmt$
\begin{itemize}
\item does $start_{state}$ need to be updated to $currentTime$?
  $\\\\$
  where
  $$inSeconds_{stmt} = isoToUnixEpoch(currentTime)$$
  $$inSeconds_{start} = isoToUnixEpoch(start_{state}) \iff start_{state} \not = nil$$
  such that
  $$start(state, stmt) = currentTime$$
  $$\iff$$
  $$start_{state} = nil$$
  $$\lor$$
  $$inSeconds_{stmt} \leq inSeconds_{start}$$
  otherwise
  $$start(state, stmt) = start_{state}$$
\item does $end_{state}$ need to be updated to $currentTime$?
  $\\\\$
  where
  $$inSeconds_{stmt} = isoToUnixEpoch(currentTime)$$
  $$inSeconds_{end} = isoToUnixEpoch(end_{state}) \iff end_{state} \not = nil$$
  such that
  $$end(state, stmt) = currentTime$$
  $$\iff$$
  $$end_{state} = nil$$
  $$\lor$$
  $$inSeconds_{stmt} \geq inSeconds_{end}$$
  otherwise
  $$end(state, stmt) = end_{state}$$
\item what should $statementCount$ be?
  $$nStmts(state) = 1 \iff statementCount_{state} = 0 \ \lor \ nil$$
  $$\lor$$
  $$nStmts(state) = 1 + statementCount_{state} \iff statementCount_{state} \geq 1$$
\item do we need to add a new $name$?
  $$allNames(state, stmt) = append(name_{state}, name_{stmt}, count(name_{state}))$$
  $$\iff$$
  $$name_{stmt} \not \in name_{state}$$
  otherwise
  $$allNames(state, stmt) = name_{state}$$
\end{itemize}
which allows for the following primitives to be defined
$$p_{start}(state, stmt) = start(state, stmt)$$
$$p_{end}(state, stmt) = end(state, stmt)$$
$$p_{stmtCount}(state, stmt) = nStmts(state)$$
$$p_{names}(state, stmt) = allNames(state, stmt)$$
and establish relevant paths into $state$
$$K_{domain} = <state, completions, objectId, domain>$$
$$K_{stmtCount} = <state, completions, objectId, statementCount>$$
$$K_{names} = <state, completions, objectId, name>$$
which are used within higher level primitives concerned with updating $state$
$$p_{updateStart}(state, stmt)$$
$$\equiv$$
$$associate(state, K_{domain}, append(remove(domain_{state}, 0), p_{start}(state, stmt), 0))$$
and
$$p_{updateEnd}(state, stmt)$$
$$\equiv$$
$$associate(state, K_{domain}, append(remove(domain_{state}, 1), p_{end}(state, stmt), 1))$$
and
$$p_{updatedCount}(state, stmt)$$
$$\equiv$$
$$associate(state, K_{stmtCount} , p_{stmtCount}(state, stmt))$$
and
$$p_{updatedNames}(state, stmt)$$
$$\equiv$$
$$associate(state, K_{names}, p_{names}(state, stmt))$$
$\\$
such that $body$ of $step$ is defined as
$$step(state, stmt) = p_{updateNames}(p_{updateCount}(p_{updateEnd}(p_{updateStart}(state, stmt), stmt), stmt), stmt)$$
where
$$state' = p_{updateStart}(state, stmt)$$
and
$$state'' = p_{updateEnd}(state', stmt)$$
and
$$state''' = p_{updateCount}(state'', stmt)$$
such that
$$step(state, stmt) = p_{updateNames}(state''', stmt)$$

\subsection{Result}
\begin{schema}{RateOfCompletionsResult[KV, KV]}
  Result \\
  opt?, state?, result! : KV \\
  result~\_ : KV \cross KV \surj KV
  \where
  Result.result = \langle body \rangle \\
  \langle body \rangle \bindsto result = \langle FIXME: ~what ~primitives ~are ~needed? \rangle \\
  result! = result(state?, opt?) @ FIXME: ~what ~happens?
\end{schema}
% WIP - bellow -> Z
The only $opts$ used by $rateOfCompletions$ is $timeUnit$
$$timeUnit = second \ \lor minute \ \lor \ hour \ \lor day \ \lor month \ \lor year$$
and will default to $day$ if not passed to $rateOfCompletions$
$$result(state) = result(state, <timeUnit \mapsto day>)$$
which is passed to $rateOf$ along with the arguments parsed from $state$
$$unit = atKey(opts, timeUnit)$$
$$allCompletions(state) = atKey(state, <state, completions>)$$
such that
$$\forall k_{n} : i..n..j \in allCompletions(state)$$
the following primitives are called each iteration
$$getCount(state, k_{n}) = atKey(allCompletions(state), <k_{n}, statementCount>)$$
$$getStart(state, k_{n}) = atKey(allCompletions(state), <k_{n}, domain, start>)$$
$$getEnd(state, k_{n}) = atKey(allCompletions(state), <k_{n}, domain, end>)$$
$$getName(state, k_{n}) = atKey(allCompletions(state), <k_{n}, name>) $$
which allows for
$$rate_{n}(state, k_{n}, unit) = rateOf(getCount(state, k_{n}), getStart(state, k_{n}), getEnd(state, k_{n}), unit)$$
such that
$$value_{n}(state, k_{n}, unit) = <x_{n}, y_{n}>$$
where
$$name_{n}(state, k_{n}) = first(getName(state, k_{n}))$$
$$x_{n} = x \mapsto name_{n}(state, k_{n}) \iff name_{n}(state, k_{n}) \not = nil$$
otherwise
$$x_{n} = x \mapsto k_{n}$$
and
$$y_{n} = y \mapsto rate_{n}(state, k_{n}, unit)$$
such that
$$value_{n}(state, k_{n}, unit) = <name_{n}(state, k_{n}), \ rate_{n}(state, k_{n}, unit)>$$
and
$$value(state, unit) = \forall k_{n} : i..n..j \in allCompletions(state) \exists! value_{n}(state, k_{n}, unit) = <x_{n}, y_{n}>$$
$$\implies$$
$$value(state, unit) = <value_{i}(state, k_{i}, unit)..value_{n}(state, k_{n}, unit)..value_{j}(state, k_{j}, unit)>$$
which allows the body of $result$ to be defined using
$$unit = atKey(opts, timeUnit)$$
$$K_{store} = <state, completions, values, unit>$$
so that $result$ returns an updated $state$ with the rate of completions per $unit$ located at $K_{store}$
$$result(state, opts) = associate(state, K_{store}, value(state, unit))$$

\end{document}
