\documentclass[../main.tex]{subfiles}
\externaldocument{../algorithms/introduction}

\begin{document}

\section{Rate of Completions}
As learners engage in activities supported by a learning ecosystem, they will build
up a history of learning experiences. When the digital resources of that learning ecosystem
adhere to a framework dedicated to supporting and understanding the
learner, such as the Total Learning Architecture (TLA), the data produced by the learning ecosystem
will contribute to each learner's digital footprint. One way that footprint can be made actionable is
through analysis of trends and/or patterns of activity. The following
Algorithm does exactly this but scoped to:
\begin{itemize}
\item events describing or asserting that a learner completed a learning activity or exercise.
\item events which happened within some target window of time
\end{itemize}
\subsection{Alignment to DAVE Algorithm Definition}
The schema $RateOfCompletions$ serves as the first formal definition of an Algorithm which implements
the definition of a DAVE Algorithm presented in the section \nameref{AFD_ref}(\ref{AFD_ref}) on page \pageref{AFD_ref}.
$RateOfCompletions$ is used to introduce the alignment between the generic components of $Algorithm$ and their
corresponding definitions within this domain specific use case. In general, all DAVE Algorithm definitions must reference the
schema $Algorithm$ and the schemas corresponding to the different components of $Algorithm$. Within $RateOfCompletions$,
both $Algorithm.algorithm.algorithmIter$ and $ROCalgorithmIter$ are fully expanded for clarity. This is not a requirement
of alignment schemas, but alignment schemas should feature:
\begin{itemize}
\item an expanded definition of the use case specific $algorithmIter$
\item binding of the use case specific $algorithmIter$ to $Algorithm.algorithm.algorithmIter$
\end{itemize}
Typically, an alignment schema would be defined after its component schemas but because $RateOfCompletions$
is the first of its kind, it is featured first to introduce the notation by example and set the stage
for the following component definitions. The alignments established in $RateOfCompletions$ are further
expanded upon within the corresponding definition of each individual component.

\subsubsection{Components}
Within each component definition, in order to connect the dots between
\begin{itemize}
  \item $Algorithm$ and its components
  \item $RateOfCompletions$ and its components
\end{itemize}
the symbol $\bindsto$ is used. This establishes that the constraints defined in the more generic
component formal definitions apply to the schema being binded to. This is formalized within each of
the $RateOfCompletions$ component schemas via
\begin{axdef}
  genericSchema.primitiveName = \langle body \rangle
  \where
  \langle body \rangle \bindsto localSchema.primitiveName = localSchema.primitiveChain
\end{axdef}

\subsection{Formal Definition}
The application of the notation described above to $RateOfCompletions$ results
in the following definition with respect to schemas
\begin{zed}
  RateOfCompletions ::= \\
  \t2 Algorithm ~\comp RateOfCompletions ~\implies \\
  \t4 (Init ~\comp ~RateOfCompletionsInit) ~ \land \\
  \t4 (Relevant? ~\comp ~RateOfCompletionsRelevant?) ~\land \\
  \t4 (Accept? ~\comp ~RateOfCompletionsAccept?) ~\land \\
  \t4 (Step ~\comp ~RateOfCompletionsStep) ~\land \\
  \t4 (Result ~\comp ~RateOfCompletionsResult)
\end{zed}
such that the $\langle body \rangle$ within each of the generic schema definitions is substituted for
the Primitive chain defined within each of the local schemas. Here, the components of $RateOfCompletions$
use a naming scheme of Container + AlgorithmComponent but this pattern is not required. It is used here
strictly for additional highlighting of the syntax introduced above for connecting the generic
definition of an Algorithm to an Implementation of that methedology much like the concepts underlying
\href{https://docs.oracle.com/javase/tutorial/java/concepts/interface.html}{Java Interfaces}.
\begin{schema}{\Delta RateOfCompletions[KV, Collection, KV]}
  Algorithm \\
  RateOfCompletionsInit \\
  RateOfCompletionsRelevant? \\
  RateOfCompletionsAccept? \\
  RateOfCompletionsStep \\
  RateOfCompletionsResult \\
  rateOfCompletions~\_ : KV \cross Collection \cross KV \surj KV \\
  state?, opt?, state! : KV \\
  S? : Collection
  \where
  Algorithm.algorithm.algorithmIter = \langle relevant?~\_~, accept?~\_~, step~\_ \rangle \\
  ROCalgorithmIter = \langle RateOfCompletionsRelevant?.relevant?~\_~, \\
  \t5 \ RateOfCompletionsAccept?.accept?~\_~, \\
  \t5 \ RateOfCompletionsStep.step~\_ \rangle \\ ~ \\

  Algorithm.algorithm.algorithmIter~\_~ \bindsto ROCalgorithmIter~\_~ \implies \\
  \t1 (Algorithm.algorithm.algorithmIter.relevant?~\_ \bindsto \\
  \t3 RateOfCompletionsRelevant?.relevant?~\_)  ~\land \\
  \t1 (Algorithm.algorithm.algorithmIter.accept?~\_ \bindsto \\
  \t3 RateOfCompletionsAccept?.accept?~\_) ~\land \\
  \t1 (Algorithm.algorithm.algorithmIter.step~\_ \bindsto \\
  \t3 RateOfCompletionsStep.step~\_) \\ ~ \\

  state! = rateOfCompletions(state?, S?, opt?) \equiv algorithm(state?, S?, opt?) \iff \\
  \t3 (Algorithm.algorithm.init~\_ \bindsto RateOfCompletionsInit.init~\_) ~\land \\
  \t3 (Algorithm.algorithm.algorithmIter~\_ \bindsto ROCalgorithmIter~\_) ~ \land \\
  \t3 (Algorithm.algorithm.result~\_ \bindsto RateOfCompletionsResult.result~\_)
\end{schema}
\begin{itemize}
\item the $.$ notation is used to reference components within a schema
\item the $\bindsto$ represents alignment between components of $Algorithm$ and $RateOfCompletions$
\item the $\Delta$ in the schema name indicates that $RateOfCompletions$ alters the state space of $Algorithm$
  due to usage of $\bindsto$
\end{itemize}

\subsection{Initialization}
The first example of a component to component alignment is found within $RateOfCompletionsInit$ which shows
how the primitive $RateOfCompletionsInit.init$ is bound to $\langle body \rangle$ within $Algorithm.algorithm.init$. Specifically,
the schema $RateOfCompletionsInit$ uses the Primtive $updateAt$ such that $init_{\delta}$ can be used to establish the initialization logic.

\subsubsection{Formal Definition}
In the following, $init_{\delta}$ could have been a stand alone Operation referenced within $RateOfCompletionsInit$.
\begin{schema}{RateOfCompletionsInit[KV]}
  Init, UpdateAt \\
  state?, state! : KV \\
  init~\_ : KV \surj KV \\
  init_{\delta} : V \surj KV \\
  \where
  Init.init = \langle body \rangle \\
  init = \langle updateAt~\_ \rangle \\
  Init.init \bindsto init \implies \langle body \rangle \equiv \langle updateAt~\_ \rangle

  \\ ~ \\
  init_{\delta}! ~= init_{\delta}(state?_{\langle roc, completions \rangle}) @ \\
  \t1 ~~~~ = \ (\emptyset \iff \langle roc, completions \rangle \not \in state?) ~\lor \\
  \t2 (state?_{\langle roc, completions \rangle} \iff \langle roc, completions \rangle \in state?) \\ ~ \\

  state! = init(state?) = updateAt(state?, \langle roc, completions \rangle, init_{\delta}) @ \\
  \t1 \ \  = ~ (\ldata roc \mapsto completions \mapsto \emptyset \rdata \cup state? \iff init_{\delta}! = \emptyset) ~\lor \\
  \t2 (state? \iff init_{\delta}! \not= \emptyset)
\end{schema}
The output of $RateOfCompletionsInit.init$ is $state!$ which can be one of two things given the definition of $init_{\delta}$
\begin{itemize}
\item $state! = \ldata roc \mapsto completions \mapsto \emptyset \rdata \cup state?$
\item $state! = state?$
\end{itemize}
This means that the result of any previous runs of $rateOfCompletions$ will not be overwritten
but if this is the first iteration of the Algorithm, the necessary storage location is established
within the Algorithm State such that
\begin{itemize}
\item $RateOfCompletionsStep.step$ can write its output to $state!_{\langle roc, completions \rangle}$
\item $RateOfCompletionsResult.result$ can read from $state!_{\langle roc, completions \rangle}$
\end{itemize}
and by defining $RateOfCompletionsInit.init$ in this way, it allows for chaining of calls to $rateOfCompletion$ such that
\begin{itemize}
\item the Algorithm can pick back up from the result of a previous iteration
\item Other Algorithms can use the result of $rateOfCompletions$ within their processing
\end{itemize}
which highlights the importance of establishing a unique path for individual Algorithms to write their results to.
The example $path?$ of $\langle roc, completions \rangle$ is very simple but is sufficient for the current Algorithm.
This $path?$ can be made more complex to suppport more advanced $init_{\delta}$ definitions. For example, each run of
$rateOfCompletions$ could have its own unique subpath. In this scenario, $init_{\delta}$ could be updated to look for
the most recent run of $rateOfCompletions$ and use it as the seed state for the current iteration among other things.
\begin{itemize}
\item $\langle roc, completions, run1 \rangle$
\item $\langle roc, completions, run2 \rangle$
\end{itemize}

\subsubsection{Big Picture}
When Algorithms write to a unique location within an Algorithm State, high level Algorithms can be designed which
chain together individual Algorithms such that the result of one is used to seed the next. Chaining together of Algorithms
is a subject not yet covered within this report and its exact form is still under active development. It is mentioned here
to highlight the ideal usage of Algorithm State in the context of $init$; Algorithm State is a mutable $Map$ which
serves as a storage location for a collection of Algorithm(s) to write to and/or read from such that an Algorithm
can
\begin{itemize}
\item pick up from a previous iteration
\item use the output of other Algorithm(s) to initialize the current state
\item process quantities of data too large to store in local memory all at once
\end{itemize}

\subsection{Relevant?}
Given that the purpose of $relevant?$ is to determine if the current Statement ($stmt?$)
is valid for use within $step$ of $rateOfCompletions$, the validation check itself can
be implemented in several different ways but idealy, the predicate logic is expressed using the
\href{https://github.com/adlnet/xapi-profiles/blob/master/xapi-profiles-about.md}{xAPI Profiles spec}.

\subsubsection{xAPI Profile Validation}
The specification defines
\href{https://github.com/adlnet/xapi-profiles/blob/master/xapi-profiles-structure.md#statment-templates}{xAPI Statement Tempaltes}
which feature a built in
\href{https://github.com/adlnet/xapi-profiles/blob/master/xapi-profiles-structure.md#81-statement-template-rules}{xAPI property predicate language}
for defining the uniquely identifying properties of an xAPI Statement. These requirements are used within
validation logic aligned to/based off of the
\href{https://github.com/adlnet/xapi-profiles/blob/master/xapi-profiles-communication.md#statement-template-valid}{Statement Template Validation Logic}
defined in the spec. The formal definition of Statement Template validation logic is outside the scope
of this document but the following basic type is introduced to represent an xAPI Statement Tempalte
$$[TEMPLATE_{stmt}]$$
such that the following is an Operation definition for validation of an xAPI Statement $stmt?$ against an xAPI Statement Template.
%FIXME: footnote, the Operation returns a boolean so it ends with a ?, one instance of overlap between input arg and pred fn naming conventions
\begin{schema}{ValidateStatement[STATEMENT, TEMPLATE_{stmt}]}
  stmt? : STATEMENT \\
  template? : TEMPLATE_{stmt} \\
  validateStmt! : Boolean \\
  validateStmt~\_ : STATEMENT \cross TEMPLATE_{stmt} \fun Boolean
  \where
  validateStmt! = validateStmt(stmt?, template?) = true ~\lor false
\end{schema}
This Operation can be composed with other xAPI Profile centered Operations to define more complex
predicate/validation logic like:
\begin{itemize}
  \item $stmt?$ matches target xAPI Statement Template(s) defined within some xAPI Profile(s)
  \item $stmt?$ matches pred (ie, any/none/etc.) xAPI Statement Template(s) defined within some xAPI Profile(s)
  \item $stmt?$ matches target/pred xAPI Statement Template(s) within target/pred xAPI Pattern(s) defined within some xAPI Profile(s)
\end{itemize}

\subsubsection{xAPI Predicates}
In order to avoid brining in additional xAPI Profile complexity, the logic of
$RateOfCompletionsRelevant?$ is implemented using predicates which correspond to
checks which would happen during $validateStmt$ given Statement Templates containing
the following constraints.
\begin{itemize}
\item is the Object of the Statement an Activity?
\item is the Verb indicative of a completion event?
\item is Result.completion used to indicate completion?
\end{itemize}
In general, each of these Primitives navigates into a Statement to retrieve the value at a target
$path?$ and check it against the predicate defined in the schema. This generic functionality is defined
as the Primitive $stmtPred$.
\begin{schema}{StatementPredicate[STATEMENT, Collection, (~\_~\pfun~\_~)]}
  GetIn \\
  stmt? : STATEMENT \\
  path? : Collection \\
  fn_{pred}! : Boolean \\
  fn_{pred}? : (~\_~\pfun~\_~) \\
  stmtPred~\_ : STATEMENT \cross Collection \cross (~\_~\pfun~\_~) \fun Boolean
  \where
  stmtPred = \langle getIn~\_~, fn_{pred}?(stmt?_{path?}) \rangle \\ ~ \\
  fn_{pred}! = stmtPred(stmt?, path?, fn_{pred?}) \\
  \t1 \ \ \ ~ = fn_{pred}?(getIn(stmt?, path?)) @ \\
  \t1 \ \ \ ~ = true ~\lor~ false
\end{schema}
This Primitive covers the most basic kind of check performed when validating an xAPI Statement
against an xAPI Statement Template; does the Statement property found at $stmt?_{path?}$ adhere to
the expectation(s) defined within the provided predicate. The next three schemas will define
the statement predicates used within $RateOfCompletionsRelevant?$ but these predicates
could have been contained within some number of xAPI Statement Template(s).

\begin{schema}{ActivityObject?[STATEMENT]}
  StatementPredicate \\
  stmt? : STATEMENT \\
  path? : Collection \\
  fn_{pred}! : Boolean \\
  fn_{pred}~\_ : V \fun Boolean \\
  activityObject?~\_ : STATEMENT \fun Boolean
  \where
  activityObject? = \langle stmtPred~\_ \rangle \\ ~ \\

  path? = \langle object, objectType \rangle \\ ~ \\

  fn_{pred}! = activityObject?(stmt?) \\
  \t1 \ \ \ \ = stmtPred(stmt?, path?, fn_{pred}) \\
  \t1 \ \ \ \ = fn_{pred}(stmt?_{path?}) \\
  \t1 \ \ \ \ = true \iff stmt?_{path?} = Activity ~\lor ~ \emptyset
\end{schema}
\begin{itemize}
  \item Determine if the Object of $stmt?$ is an \href{https://github.com/adlnet/xAPI-Spec/blob/master/xAPI-About.md#def-activity}{Activity}
\end{itemize}

\begin{schema}{CompletionVerb?[STATEMENT]}
  StatementPredicate \\
  stmt? : STATEMENT \\
  path? : Collection \\
  fn_{pred}! : Boolean \\
  fn_{pred}~\_ : V \fun Boolean \\
  completionVerb?~\_ : STATEMENT \fun Boolean
  \where
  completionVerb? = \langle stmtPred~\_ \rangle \\ ~ \\

  path? = \langle verb, id \rangle \\ ~ \\

  fn_{pred}! = completionVerb?(stmt?) \\
  \t1 \ \ \ \ = stmtPred(stmt?, path?, fn_{pred}) \\
  \t1 \ \ \ \ = fn_{pred}(stmt?_{path?}) \\
  \t1 \ \ \ \ = true \iff stmt?_{path?} = \\
  \t3 http://adlnet.gov/expapi/verbs/passed ~~\lor \\
  \t3 https://w3id.org/xapi/dod-isd/verbs/answered ~~\lor \\
  \t3 http://adlnet.gov/expapi/verbs/completed
\end{schema}

\begin{itemize}
\item Determine if the Verb id within $stmt?$ is one of
  \begin{itemize}
  \item passed
  \item answered
  \item completed
  \end{itemize}
\item List of target Verb ids can be expanded as needed
\end{itemize}

\begin{schema}{CompletionResult?[STATEMENT]}
  StatementPredicate \\
  stmt? : STATEMENT \\
  path? : Collection \\
  fn_{pred}! : Boolean \\
  fn_{pred}~\_ : V \fun Boolean \\
  completionResult?~\_ : STATEMENT \fun Boolean
  \where
  completionResult? = \langle stmtPred~\_ \rangle \\ ~ \\

  path? = \langle result, completion \rangle \\ ~ \\

  fn_{pred}! = completionResult?(stmt?) \\
  \t1 \ \ \ \ = stmtPred(stmt?, path?, fn_{pred}) \\
  \t1 \ \ \ \ = fn_{pred}(stmt?_{path?}) \\
  \t1 \ \ \ \ = true \iff stmt?_{path?} = true \\
\end{schema}

\begin{itemize}
  \item Determine if completion is set to true within result field of an xAPI Statement
\end{itemize}

\subsubsection{Formal Definition}
The xAPI Predicates defined above are used within $RateOfCompletionsRelevant?$ to
establish the logic which decides if $stmt?$ is
\begin{itemize}
\item passed on to the next step
\item discarded for the next Statement in the batch passed to $rateOfCompletions$
\end{itemize}

\begin{schema}{\Xi RateOfCompletionsRelevant?[KV, STATEMENT]}
  Relevant? \\
  state? : KV \\
  stmt? : STATEMENT \\
  relevant! : Boolean \\
  relevant?~\_ : KV \cross STATEMENT \fun Boolean
  \where
  Relevant.relevant? = \langle body \rangle \\
  \langle body \rangle \bindsto relevant? = \langle ~activityObject?~\_~, \langle ~completionVerb?~\_~, ~completionResult?~\_ \rangle  \rangle \\ ~ \\
  relevant! = relevant?(state?, stmt?) \\
  \t2 ~ = true \iff (activityObject(stmt?) = true) ~\land \\
  \t6 \ ~ ((completionVerb?(stmt?) = true) ~\lor \\
  \t6 \ \ ~ (completionResult?(stmt?) = true))
\end{schema}
The schema prefix $\Xi$ is used to indicate that here, $relevant?$ does not modify $state?$.
Regardless, in order for $relevant?$ to return true
\begin{itemize}
\item The object of $stmt?$ must be an activity
\item The Verb of $stmt?$ has an id which matches one of the target IDs
\item The Result of $stmt$ indicates that a completion happened
\end{itemize}

\subsection{Accept?}
\begin{schema}{RateOfCompletionsAccept?[KV, STATEMENT]}
  Accept? \\
  state? : KV \\
  stmt? : STATEMENT \\
  accept! : Boolean \\
  accept?~\_ : KV \cross STATEMENT \fun Boolean
  \where
  Accept?.accept? = \langle body \rangle \\
  \langle body \rangle \bindsto accept? = \langle FIXME: ~what ~primitives ~are ~needed? \rangle \\
  accept! = accept?(state?, stmt?) @ FIXME: ~what ~happens?
\end{schema}
% WIP - bellow -> Z
$rateOfCompletions$ does not require further boolean logic to determine if $stmt$ and $state$ can be passed to $step$
$$accept?(state, stmt) = object?(stmt)$$
which should always return true assuming valid xAPI Statements are passed to $rateOfCompletions$

\subsection{Step}
\begin{schema}{RateOfCompletionsStep[KV, STATEMENT]}
  Step \\
  state?, step! : KV \\
  stmt? : STATEMENT \\
  step~\_ : KV \cross STATEMENT \surj KV
  \where
  Step.step = \langle body \rangle \\
  \langle body \rangle \bindsto step = \langle FIXME: ~what ~primitives ~are ~needed? \rangle \\
  step! = step(state?, stmt?) @  FIXME: ~what ~happens?
\end{schema}
% WIP - bellow -> Z
\subsubsection{summary}
$step(state, stmt)$ updates $state$ to include
$$\$.object.id \mapsto <domain, statementCount, name>$$
where
$$domain \mapsto <start, end> $$
$$statementCount \mapsto \real$$
$$name \mapsto <\$.object.definition.name>$$
at
$$<state, completions, \$.object.id>$$

\subsubsection{processing}
$step$ starts by extracting the relevant information from $stmt$
\begin{itemize}
\item $currentTime$
  $$currentTime = atKey(stmt, timestamp)$$
\item $name$
  $$name_{stmt} = atKey(stmt, <object, definition, name>)$$
\item $objectId$
  $$objectId = atKey(stmt, <object, id>)$$
\end{itemize}
which allows for the previous $state$ to be resolved using $objectId$
\begin{itemize}
\item $domain$
  $$domain_{state} = atKey(state, <state, completions, objectId, domain>)$$
  $$start_{state} = first(domain_{state})$$
  $$end_{state} = last(domain_{state})$$
\item $statementCount$
  $$statementCount_{state} = atKey(state, <state, completions, objectId, statementCount>)$$
\item $name$
  $$name_{state} = atKey(state, <state, completions, objectId, name>)$$
\end{itemize}
so that the previous state can be used along side the information parsed from $stmt$
\begin{itemize}
\item does $start_{state}$ need to be updated to $currentTime$?
  $\\\\$
  where
  $$inSeconds_{stmt} = isoToUnixEpoch(currentTime)$$
  $$inSeconds_{start} = isoToUnixEpoch(start_{state}) \iff start_{state} \not = nil$$
  such that
  $$start(state, stmt) = currentTime$$
  $$\iff$$
  $$start_{state} = nil$$
  $$\lor$$
  $$inSeconds_{stmt} \leq inSeconds_{start}$$
  otherwise
  $$start(state, stmt) = start_{state}$$
\item does $end_{state}$ need to be updated to $currentTime$?
  $\\\\$
  where
  $$inSeconds_{stmt} = isoToUnixEpoch(currentTime)$$
  $$inSeconds_{end} = isoToUnixEpoch(end_{state}) \iff end_{state} \not = nil$$
  such that
  $$end(state, stmt) = currentTime$$
  $$\iff$$
  $$end_{state} = nil$$
  $$\lor$$
  $$inSeconds_{stmt} \geq inSeconds_{end}$$
  otherwise
  $$end(state, stmt) = end_{state}$$
\item what should $statementCount$ be?
  $$nStmts(state) = 1 \iff statementCount_{state} = 0 \ \lor \ nil$$
  $$\lor$$
  $$nStmts(state) = 1 + statementCount_{state} \iff statementCount_{state} \geq 1$$
\item do we need to add a new $name$?
  $$allNames(state, stmt) = append(name_{state}, name_{stmt}, count(name_{state}))$$
  $$\iff$$
  $$name_{stmt} \not \in name_{state}$$
  otherwise
  $$allNames(state, stmt) = name_{state}$$
\end{itemize}
which allows for the following primitives to be defined
$$p_{start}(state, stmt) = start(state, stmt)$$
$$p_{end}(state, stmt) = end(state, stmt)$$
$$p_{stmtCount}(state, stmt) = nStmts(state)$$
$$p_{names}(state, stmt) = allNames(state, stmt)$$
and establish relevant paths into $state$
$$K_{domain} = <state, completions, objectId, domain>$$
$$K_{stmtCount} = <state, completions, objectId, statementCount>$$
$$K_{names} = <state, completions, objectId, name>$$
which are used within higher level primitives concerned with updating $state$
$$p_{updateStart}(state, stmt)$$
$$\equiv$$
$$associate(state, K_{domain}, append(remove(domain_{state}, 0), p_{start}(state, stmt), 0))$$
and
$$p_{updateEnd}(state, stmt)$$
$$\equiv$$
$$associate(state, K_{domain}, append(remove(domain_{state}, 1), p_{end}(state, stmt), 1))$$
and
$$p_{updatedCount}(state, stmt)$$
$$\equiv$$
$$associate(state, K_{stmtCount} , p_{stmtCount}(state, stmt))$$
and
$$p_{updatedNames}(state, stmt)$$
$$\equiv$$
$$associate(state, K_{names}, p_{names}(state, stmt))$$
$\\$
such that $body$ of $step$ is defined as
$$step(state, stmt) = p_{updateNames}(p_{updateCount}(p_{updateEnd}(p_{updateStart}(state, stmt), stmt), stmt), stmt)$$
where
$$state' = p_{updateStart}(state, stmt)$$
and
$$state'' = p_{updateEnd}(state', stmt)$$
and
$$state''' = p_{updateCount}(state'', stmt)$$
such that
$$step(state, stmt) = p_{updateNames}(state''', stmt)$$

\subsection{Result}
\begin{schema}{RateOfCompletionsResult[KV, KV]}
  Result \\
  opt?, state?, result! : KV \\
  result~\_ : KV \cross KV \surj KV
  \where
  Result.result = \langle body \rangle \\
  \langle body \rangle \bindsto result = \langle FIXME: ~what ~primitives ~are ~needed? \rangle \\
  result! = result(state?, opt?) @ FIXME: ~what ~happens?
\end{schema}
% WIP - bellow -> Z
The only $opts$ used by $rateOfCompletions$ is $timeUnit$
$$timeUnit = second \ \lor minute \ \lor \ hour \ \lor day \ \lor month \ \lor year$$
and will default to $day$ if not passed to $rateOfCompletions$
$$result(state) = result(state, <timeUnit \mapsto day>)$$
which is passed to $rateOf$ along with the arguments parsed from $state$
$$unit = atKey(opts, timeUnit)$$
$$allCompletions(state) = atKey(state, <state, completions>)$$
such that
$$\forall k_{n} : i..n..j \in allCompletions(state)$$
the following primitives are called each iteration
$$getCount(state, k_{n}) = atKey(allCompletions(state), <k_{n}, statementCount>)$$
$$getStart(state, k_{n}) = atKey(allCompletions(state), <k_{n}, domain, start>)$$
$$getEnd(state, k_{n}) = atKey(allCompletions(state), <k_{n}, domain, end>)$$
$$getName(state, k_{n}) = atKey(allCompletions(state), <k_{n}, name>) $$
which allows for
$$rate_{n}(state, k_{n}, unit) = rateOf(getCount(state, k_{n}), getStart(state, k_{n}), getEnd(state, k_{n}), unit)$$
such that
$$value_{n}(state, k_{n}, unit) = <x_{n}, y_{n}>$$
where
$$name_{n}(state, k_{n}) = first(getName(state, k_{n}))$$
$$x_{n} = x \mapsto name_{n}(state, k_{n}) \iff name_{n}(state, k_{n}) \not = nil$$
otherwise
$$x_{n} = x \mapsto k_{n}$$
and
$$y_{n} = y \mapsto rate_{n}(state, k_{n}, unit)$$
such that
$$value_{n}(state, k_{n}, unit) = <name_{n}(state, k_{n}), \ rate_{n}(state, k_{n}, unit)>$$
and
$$value(state, unit) = \forall k_{n} : i..n..j \in allCompletions(state) \exists! value_{n}(state, k_{n}, unit) = <x_{n}, y_{n}>$$
$$\implies$$
$$value(state, unit) = <value_{i}(state, k_{i}, unit)..value_{n}(state, k_{n}, unit)..value_{j}(state, k_{j}, unit)>$$
which allows the body of $result$ to be defined using
$$unit = atKey(opts, timeUnit)$$
$$K_{store} = <state, completions, values, unit>$$
so that $result$ returns an updated $state$ with the rate of completions per $unit$ located at $K_{store}$
$$result(state, opts) = associate(state, K_{store}, value(state, unit))$$

\end{document}
