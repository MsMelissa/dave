\documentclass[../main.tex]{subfiles}
\externaldocument{../algorithms/introduction}

\begin{document}

\section{Rate of Completions}
As learners engage in activities supported by a learning ecosystem, they will build
up a history of learning experiences. When the digital resources of that learning ecosystem
adhere to a framework dedicated to supporting and understanding the
learner, such as the Total Learning Architecture (TLA), the data produced by the learning ecosystem
will contribute to each learner's digital footprint. One way that footprint can be made actionable is
through analysis of trends and/or patterns of activity. The following
Algorithm does exactly this but scoped to:
\begin{itemize}
\item events describing or asserting that a learner completed a learning activity or exercise.
\item events which happened within some target window of time
\end{itemize}
\subsection{Alignment to DAVE Algorithm Definition}
The schema $RateOfCompletions$ serves as the first formal definition of an Algorithm which implements
the definition of a DAVE Algorithm presented in the section \nameref{AFD_ref}(\ref{AFD_ref}) on page \pageref{AFD_ref}.
$RateOfCompletions$ is used to introduce the alignment between the generic components of $Algorithm$ and their
corresponding definitions within this domain specific use case. In general, all DAVE Algorithm definitions must reference the
schema $Algorithm$ and the schemas corresponding to the different components of $Algorithm$. Within $RateOfCompletions$,
both $Algorithm.algorithm.algorithmIter$ and $ROCalgorithmIter$ are fully expanded for clarity. This is not a requirement
of alignment schemas, but alignment schemas should feature:
\begin{itemize}
\item an expanded definition of the use case specific $algorithmIter$
\item binding of the use case specific $algorithmIter$ to $Algorithm.algorithm.algorithmIter$
\end{itemize}
Typically, an alignment schema would be defined after its component schemas but because $RateOfCompletions$
is the first of its kind, it is featured first to introduce the notation by example and set the stage
for the following component definitions. The alignments established in $RateOfCompletions$ are further
expanded upon within the corresponding definition of each individual component.

\subsubsection{Components}
Within each component definition, in order to connect the dots between
\begin{itemize}
  \item $Algorithm$ and its components
  \item $RateOfCompletions$ and its components
\end{itemize}
the symbol $\bindsto$ is used. This establishes that the constraints defined in the more generic
component formal definitions apply to the schema being binded to. This is formalized within each of
the $RateOfCompletions$ component schemas via
\begin{axdef}
  genericSchema.primitiveName = \langle body \rangle
  \where
  \langle body \rangle \bindsto localSchema.primitiveName = localSchema.primitiveChain
\end{axdef}

\subsection{Formal Definition}
The application of the notation described above to $RateOfCompletions$ results
in the following definition with respect to schemas
\begin{zed}
  RateOfCompletions ::= \\
  \t2 Algorithm ~\comp RateOfCompletions ~\implies \\
  \t4 (Init ~\comp ~RateOfCompletionsInit) ~ \land \\
  \t4 (Relevant? ~\comp ~RateOfCompletionsRelevant?) ~\land \\
  \t4 (Accept? ~\comp ~RateOfCompletionsAccept?) ~\land \\
  \t4 (Step ~\comp ~RateOfCompletionsStep) ~\land \\
  \t4 (Result ~\comp ~RateOfCompletionsResult)
\end{zed}
such that the $\langle body \rangle$ within each of the generic schema definitions is substituted for
the Primitive chain defined within each of the local schemas. Here, the components of $RateOfCompletions$
use a naming scheme of Container + AlgorithmComponent but this pattern is not required. It is used here
strictly for additional highlighting of the syntax introduced above for connecting the generic
definition of an Algorithm to an Implementation of that methedology much like the concepts underlying
\href{https://docs.oracle.com/javase/tutorial/java/concepts/interface.html}{Java Interfaces}.
\begin{schema}{\Delta RateOfCompletions[KV, Collection, KV]}
  Algorithm \\
  RateOfCompletionsInit \\
  RateOfCompletionsRelevant? \\
  RateOfCompletionsAccept? \\
  RateOfCompletionsStep \\
  RateOfCompletionsResult \\
  rateOfCompletions~\_ : KV \cross Collection \cross KV \surj KV \\
  state?, opt?, state! : KV \\
  S? : Collection
  \where
  Algorithm.algorithm.algorithmIter = \langle relevant?~\_~, accept?~\_~, step~\_ \rangle \\
  ROCalgorithmIter = \langle RateOfCompletionsRelevant?.relevant?~\_~, \\
  \t5 \ RateOfCompletionsAccept?.accept?~\_~, \\
  \t5 \ RateOfCompletionsStep.step~\_ \rangle \\ ~ \\

  Algorithm.algorithm.algorithmIter~\_~ \bindsto ROCalgorithmIter~\_~ \implies \\
  \t1 (Algorithm.algorithm.algorithmIter.relevant?~\_ \bindsto \\
  \t3 RateOfCompletionsRelevant?.relevant?~\_)  ~\land \\
  \t1 (Algorithm.algorithm.algorithmIter.accept?~\_ \bindsto \\
  \t3 RateOfCompletionsAccept?.accept?~\_) ~\land \\
  \t1 (Algorithm.algorithm.algorithmIter.step~\_ \bindsto \\
  \t3 RateOfCompletionsStep.step~\_) \\ ~ \\

  state! = rateOfCompletions(state?, S?, opt?) \equiv algorithm(state?, S?, opt?) \iff \\
  \t3 (Algorithm.algorithm.init~\_ \bindsto RateOfCompletionsInit.init~\_) ~\land \\
  \t3 (Algorithm.algorithm.algorithmIter~\_ \bindsto ROCalgorithmIter~\_) ~ \land \\
  \t3 (Algorithm.algorithm.result~\_ \bindsto RateOfCompletionsResult.result~\_)
\end{schema}
\begin{itemize}
\item the $.$ notation is used to reference components within a schema
\item the $\bindsto$ represents alignment between components of $Algorithm$ and $RateOfCompletions$
\item the $\Delta$ in the schema name indicates that $RateOfCompletions$ alters the state space of $Algorithm$
  due to usage of $\bindsto$
\end{itemize}

\subsection{Initialization}
\begin{schema}{RateOfCompletionsInit[KV]}
  Init \\
  state?, state! : KV \\
  init~\_ : KV \surj KV
  \where
  Init.init = \langle body \rangle \\
  \langle body \rangle \bindsto init = \langle FIXME: ~what ~primitives ~are ~needed? \rangle \\
  state! = init(state?) @ FIXME: ~what ~happens?
\end{schema}
% check to see if \langle state, completions \rangle exists in passed in state
% - if its there, return state without alteration
% - if its not there, add it to the passed in state and return the result.

\subsection{Relevant?}
\begin{schema}{RateOfCompletionsRelevant?[KV, STATEMENT]}
  Relevant? \\
  state? : KV \\
  stmt? : STATEMENT \\
  relevant! : Boolean \\
  relevant?~\_ : KV \cross STATEMENT \fun Boolean
  \where
  Relevant.relevant? = \langle body \rangle \\
  \langle body \rangle \bindsto relevant? = \langle FIXME: ~what ~primitives ~are ~needed? \rangle \\
  relevant! = relevant?(state?, stmt?) @ FIXME: ~what ~happens?
\end{schema}
% WIP - bellow -> Z
$relevant?(state, stmt)$ determines if $stmt$ is valid for use within $step$ of $rateOfCompletions$ and does so by
looking into various $k \to v$ within $stmt$. The following Primitives are used as the $body$ of $relevant?(state, stmt)$
\begin{itemize}
\item is the Object of the Statement an Activity?
  $$activityType = atKey(stmt, <object, objectType>)$$
  $$activity?(activityType) = true \iff activityType = Activity \ \lor activityType = nil$$
\item is the Verb indicative of a completion event?
  $$verbId = atKey(stmt, <verb, id>)$$
  $$completionVerb?(verbId) = true$$
  $$\iff$$
  $$verbId = http://adlnet.gov/expapi/verbs/passed$$
  $$\lor$$
  $$verbId = https://w3id.org/xapi/dod-isd/verbs/answered$$
  $$\lor$$
  $$verbId = http://adlnet.gov/expapi/verbs/completed$$
\item does the $stmt$ indicate completion using Result?
  $$result = atKey(stmt, <result, completion>)$$
  $$resultCompletion = true \iff result = true$$
\end{itemize}
$\\$
such that the body of $relevant?$ contains
$$p_{a}(stmt) = activity?(atKey(stmt, <object, objectType>))$$
and
$$p_{v}(stmt) = completionVerb?(atKey(stmt, <verb, id>))$$
and
$$p_{r}(stmt) = resultCompletion(atKey(stmt, <result, completion>))$$
which are used to form higher level Primitives
$$p_{continue}(stmt) = stmt \iff p_{a}(stmt) = true$$
and
$$p_{completed?}(stmt) = stmt \iff p_{v}(stmt) = true \ \lor \ p_{r}(stmt) = true$$
which results in a final Primitive $p_{return?}$
$$p_{return?}(stmt) = object?(p_{completed?}(p_{continue}(stmt)))$$
which defines the $body$ of $relevant?$
$$relevant?(stmt) = p_{return?}(stmt) \implies object?(p_{completed?}(p_{continue}(stmt)))$$
and can be summarized as
$$relevant?(state, stmt) = true$$
$$\iff$$
$$activity?(activitType) = true$$
$$\land$$
$$completionVerb?(verbId) = true \ \lor \ resultCompletion = true$$

\subsection{Accept?}
\begin{schema}{RateOfCompletionsAccept?[KV, STATEMENT]}
  Accept? \\
  state? : KV \\
  stmt? : STATEMENT \\
  accept! : Boolean \\
  accept?~\_ : KV \cross STATEMENT \fun Boolean
  \where
  Accept?.accept? = \langle body \rangle \\
  \langle body \rangle \bindsto accept? = \langle FIXME: ~what ~primitives ~are ~needed? \rangle \\
  accept! = accept?(state?, stmt?) @ FIXME: ~what ~happens?
\end{schema}
% WIP - bellow -> Z
$rateOfCompletions$ does not require further boolean logic to determine if $stmt$ and $state$ can be passed to $step$
$$accept?(state, stmt) = object?(stmt)$$
which should always return true assuming valid xAPI Statements are passed to $rateOfCompletions$

\subsection{Step}
\begin{schema}{RateOfCompletionsStep[KV, STATEMENT]}
  Step \\
  state?, step! : KV \\
  stmt? : STATEMENT \\
  step~\_ : KV \cross STATEMENT \surj KV
  \where
  Step.step = \langle body \rangle \\
  \langle body \rangle \bindsto step = \langle FIXME: ~what ~primitives ~are ~needed? \rangle \\
  step! = step(state?, stmt?) @  FIXME: ~what ~happens?
\end{schema}
% WIP - bellow -> Z
\subsubsection{summary}
$step(state, stmt)$ updates $state$ to include
$$\$.object.id \mapsto <domain, statementCount, name>$$
where
$$domain \mapsto <start, end> $$
$$statementCount \mapsto \real$$
$$name \mapsto <\$.object.definition.name>$$
at
$$<state, completions, \$.object.id>$$

\subsubsection{processing}
$step$ starts by extracting the relevant information from $stmt$
\begin{itemize}
\item $currentTime$
  $$currentTime = atKey(stmt, timestamp)$$
\item $name$
  $$name_{stmt} = atKey(stmt, <object, definition, name>)$$
\item $objectId$
  $$objectId = atKey(stmt, <object, id>)$$
\end{itemize}
which allows for the previous $state$ to be resolved using $objectId$
\begin{itemize}
\item $domain$
  $$domain_{state} = atKey(state, <state, completions, objectId, domain>)$$
  $$start_{state} = first(domain_{state})$$
  $$end_{state} = last(domain_{state})$$
\item $statementCount$
  $$statementCount_{state} = atKey(state, <state, completions, objectId, statementCount>)$$
\item $name$
  $$name_{state} = atKey(state, <state, completions, objectId, name>)$$
\end{itemize}
so that the previous state can be used along side the information parsed from $stmt$
\begin{itemize}
\item does $start_{state}$ need to be updated to $currentTime$?
  $\\\\$
  where
  $$inSeconds_{stmt} = isoToUnixEpoch(currentTime)$$
  $$inSeconds_{start} = isoToUnixEpoch(start_{state}) \iff start_{state} \not = nil$$
  such that
  $$start(state, stmt) = currentTime$$
  $$\iff$$
  $$start_{state} = nil$$
  $$\lor$$
  $$inSeconds_{stmt} \leq inSeconds_{start}$$
  otherwise
  $$start(state, stmt) = start_{state}$$
\item does $end_{state}$ need to be updated to $currentTime$?
  $\\\\$
  where
  $$inSeconds_{stmt} = isoToUnixEpoch(currentTime)$$
  $$inSeconds_{end} = isoToUnixEpoch(end_{state}) \iff end_{state} \not = nil$$
  such that
  $$end(state, stmt) = currentTime$$
  $$\iff$$
  $$end_{state} = nil$$
  $$\lor$$
  $$inSeconds_{stmt} \geq inSeconds_{end}$$
  otherwise
  $$end(state, stmt) = end_{state}$$
\item what should $statementCount$ be?
  $$nStmts(state) = 1 \iff statementCount_{state} = 0 \ \lor \ nil$$
  $$\lor$$
  $$nStmts(state) = 1 + statementCount_{state} \iff statementCount_{state} \geq 1$$
\item do we need to add a new $name$?
  $$allNames(state, stmt) = append(name_{state}, name_{stmt}, count(name_{state}))$$
  $$\iff$$
  $$name_{stmt} \not \in name_{state}$$
  otherwise
  $$allNames(state, stmt) = name_{state}$$
\end{itemize}
which allows for the following primitives to be defined
$$p_{start}(state, stmt) = start(state, stmt)$$
$$p_{end}(state, stmt) = end(state, stmt)$$
$$p_{stmtCount}(state, stmt) = nStmts(state)$$
$$p_{names}(state, stmt) = allNames(state, stmt)$$
and establish relevant paths into $state$
$$K_{domain} = <state, completions, objectId, domain>$$
$$K_{stmtCount} = <state, completions, objectId, statementCount>$$
$$K_{names} = <state, completions, objectId, name>$$
which are used within higher level primitives concerned with updating $state$
$$p_{updateStart}(state, stmt)$$
$$\equiv$$
$$associate(state, K_{domain}, append(remove(domain_{state}, 0), p_{start}(state, stmt), 0))$$
and
$$p_{updateEnd}(state, stmt)$$
$$\equiv$$
$$associate(state, K_{domain}, append(remove(domain_{state}, 1), p_{end}(state, stmt), 1))$$
and
$$p_{updatedCount}(state, stmt)$$
$$\equiv$$
$$associate(state, K_{stmtCount} , p_{stmtCount}(state, stmt))$$
and
$$p_{updatedNames}(state, stmt)$$
$$\equiv$$
$$associate(state, K_{names}, p_{names}(state, stmt))$$
$\\$
such that $body$ of $step$ is defined as
$$step(state, stmt) = p_{updateNames}(p_{updateCount}(p_{updateEnd}(p_{updateStart}(state, stmt), stmt), stmt), stmt)$$
where
$$state' = p_{updateStart}(state, stmt)$$
and
$$state'' = p_{updateEnd}(state', stmt)$$
and
$$state''' = p_{updateCount}(state'', stmt)$$
such that
$$step(state, stmt) = p_{updateNames}(state''', stmt)$$

\subsection{Result}
\begin{schema}{RateOfCompletionsResult[KV, KV]}
  Result \\
  opt?, state?, result! : KV \\
  result~\_ : KV \cross KV \surj KV
  \where
  Result.result = \langle body \rangle \\
  \langle body \rangle \bindsto result = \langle FIXME: ~what ~primitives ~are ~needed? \rangle \\
  result! = result(state?, opt?) @ FIXME: ~what ~happens?
\end{schema}
% WIP - bellow -> Z
The only $opts$ used by $rateOfCompletions$ is $timeUnit$
$$timeUnit = second \ \lor minute \ \lor \ hour \ \lor day \ \lor month \ \lor year$$
and will default to $day$ if not passed to $rateOfCompletions$
$$result(state) = result(state, <timeUnit \mapsto day>)$$
which is passed to $rateOf$ along with the arguments parsed from $state$
$$unit = atKey(opts, timeUnit)$$
$$allCompletions(state) = atKey(state, <state, completions>)$$
such that
$$\forall k_{n} : i..n..j \in allCompletions(state)$$
the following primitives are called each iteration
$$getCount(state, k_{n}) = atKey(allCompletions(state), <k_{n}, statementCount>)$$
$$getStart(state, k_{n}) = atKey(allCompletions(state), <k_{n}, domain, start>)$$
$$getEnd(state, k_{n}) = atKey(allCompletions(state), <k_{n}, domain, end>)$$
$$getName(state, k_{n}) = atKey(allCompletions(state), <k_{n}, name>) $$
which allows for
$$rate_{n}(state, k_{n}, unit) = rateOf(getCount(state, k_{n}), getStart(state, k_{n}), getEnd(state, k_{n}), unit)$$
such that
$$value_{n}(state, k_{n}, unit) = <x_{n}, y_{n}>$$
where
$$name_{n}(state, k_{n}) = first(getName(state, k_{n}))$$
$$x_{n} = x \mapsto name_{n}(state, k_{n}) \iff name_{n}(state, k_{n}) \not = nil$$
otherwise
$$x_{n} = x \mapsto k_{n}$$
and
$$y_{n} = y \mapsto rate_{n}(state, k_{n}, unit)$$
such that
$$value_{n}(state, k_{n}, unit) = <name_{n}(state, k_{n}), \ rate_{n}(state, k_{n}, unit)>$$
and
$$value(state, unit) = \forall k_{n} : i..n..j \in allCompletions(state) \exists! value_{n}(state, k_{n}, unit) = <x_{n}, y_{n}>$$
$$\implies$$
$$value(state, unit) = <value_{i}(state, k_{i}, unit)..value_{n}(state, k_{n}, unit)..value_{j}(state, k_{j}, unit)>$$
which allows the body of $result$ to be defined using
$$unit = atKey(opts, timeUnit)$$
$$K_{store} = <state, completions, values, unit>$$
so that $result$ returns an updated $state$ with the rate of completions per $unit$ located at $K_{store}$
$$result(state, opts) = associate(state, K_{store}, value(state, unit))$$

\end{document}
