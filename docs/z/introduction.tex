\documentclass[../main.tex]{subfiles}

\begin{document}

\section{Z Notation Introduction}

The following subsections provide a high level overview of select properties of Z Notation based on
"The Z Notation: A Reference Manual" by J. M. Spivey. A copy
of this reference manual can be found at dave/docs/z/Z-notation reference manual.pdf.
In many cases, definitions will be pulled directly from the reference manual and when this occurs,
the relevant page number(s) will be included. For a proper introduction with tutorial examples, see
chapter 1, "Tutorial Introduction" from pages 1 to 23. For the $LaTeX$ symbols used to write Z,
see the reference document found at dave/docs/z/zed-csp-documentation.pdf.

\subsection{Variable Syntax}
The following syntax for variables used within Schemas can be found throughout this document.
This subsection presents a very small subset of all syntax within the Z language.
\begin{argue}
  ' & indicates a variable which contains the final state of an operation \\
  ? & indicates a variable which serves as input to an operation \\
  ! & indicates a variable which serves as the output of an operation
\end{argue}

\subsection{Types}
Objects have a type which characterizes them and distingues them from other kinds of objects.
\begin{itemize}
\item Basic types are sets of objects which have no internal structure of interest meaning the concrete definition of the members
  is not relevant, only their shared type.
\item Free types are used to describe (potentially nested and/or recursive) sets of objects. In the most simple case, a free type
  can be an enumeration of constants.
\end{itemize}
Within the xAPI Formal Specification, both of these types are used to describe the
\href{https://github.com/adlnet/xAPI-Spec/blob/master/xAPI-Data.md#inversefunctional}{Inverse Functional Identifier}
property.
\begin{itemize}
\item Introduction of the basic types $MBOX$, $MBOX\_SHA1SUM$, $OPENID$ and $ACCOUNT$
  allows the specification to talk about these aspects of the xAPI specification without
  defining their exact structure
\item The free type $IFI$ is defined as one of the above basic types meaning an object
  of type $IFI$ is of type $MBOX$ or $MBOX\_SHA1SUM$ or $OPENID$ or $ACCOUNT$
  which allows for Inverse Functional Identifiers to be used in the formal specification
  without concern for their distinct concrete definitions.
\end{itemize}
Types can be composed together to form composite types and thus objects, the members of types,
are composable to create complex objects.
\begin{zed}
  [MBOX, MBOX\_SHA1SUM, OPENID, ACCOUNT]
  \also
  IFI ::= MBOX \,|\, MBOX\_SHA1SUM \,|\, OPENID \,|\, ACCOUNT
\end{zed}
Within the xAPI Formal Specification, $IFI$ is used within the definition
of an $agent$ as presented in the schema $Agent$.

\begin{schema}{Agent}
  agent : AGENT \\
  objectType : OBJECTTYPE \\
  name : \finset_1 \#1 \\
  ifi : IFI
  \where
  objectType = Agent \\
  agent = \{ifi\} \cup \power \{name, objectType\}
\end{schema}
See section 2.2, pages 28 to 34, and chapter 3, pages 42 to 85, for more information about Schemas and the Z Language.

\subsection{Sets}
A collection of elements that all share a type. A set is characterized solely by which objects are members and which are not.
Both the order and repetition of objects are ignored. Sets are written in one of two ways:
\begin{itemize}
\item listing their elements
\item by a property which is characteristic of the elements of the set.
\end{itemize}
such that the following law from page 55 holds for some object y
$$y \in \{x_{1},...,x_{n}\} \iff y - x_{1} \lor ... \lor y = x_{n}$$

\subsection{Ordered Pairs}
Two or more objects $(x, y)$ where $x$ is paired with $y$ where equality between two n-tuple pairs is given by the law from page 55
$$(x_{1},...,x_{n}) = (y_{1},...,y_{n}) \iff x_{1} = y_{1} \land ... \land x_{n} = y_{n}$$
When ordered pairs are used with respect to application (as seen on page 60)
$$f x \implies f(x) \iff (x,y) \in f$$
which states that $f(x)$ is defined if and only if there is a unique value $y$ which result from $f x$
Additionally, application associates to the left
$$f x y \implies (f x) y \implies (f(x), y)$$
meaning $f(x)$ results in a function which is then applied to $y$.

\subsection{Sequences}
A collection of elements where their ordering matters such that
$$\langle a_{1},...,a_{n} \rangle \implies \{1 \mapsto a_{1}, ..., n \mapsto a_{n}\}$$
as seen on page 115. Additionally, $\iseq$ is used to describe a sequence whose members are distinct.

\subsection{Bags}
A collection of elements where the number of times an element appears in the collection is meaningful.
$$\lbag a_{1},...,a_{n} \rbag \implies \{a_{1} \mapsto c_{1},...,a_{n} \mapsto c_{n}\}$$
As described on page 124 (replacing $c$ with $k$), each element $a_{i}$ appears $c_{i}$ times in the list $a_{1},...,a_{n}$
such that the number of occurances of $a_{i}$ within bag $A$ is returned by
$$count ~A ~a_{i} \ \equiv A ~\# ~a_{i}$$

\subsection{Maps}
This document introduces a named subcategory of sets, $map$ of the free type $KV$,
which are akin to sequences and bags. To enumerate the members of a $map$, $\ldata ... \rdata$ is used
but should not be confused with $d_{i}\ldata E_{i}[T]\rdata$ within a Free Type definition. The
distinction between the two usages is context dependent but in general, if $\ldata ... \rdata$
is used outside of a constructor declaration within a Free Type definition,
it should be assumed to represent a $map$.
$$KV ::= base ~| ~associate\ldata KV \cross X \cross Y \rdata$$
where
\begin{argue}
  base & is a constant which is the empty $KV \implies \ldata \rdata$ \\
  associate & is a constructor and is infered to be an injection
\end{argue}
The full enumeration of all properties, constraints and functions
specific to a $map$ with type $KV$ will be defined elsewhere but
$associate$ can be understood to (in the most basic case) operate as follows.
$$associate(base, x_{i}, y_{i}) = \ldata (x_{i}, y_{i}) \rdata \implies \ldata x_{i} \mapsto y_{i} \rdata$$
The enumeration of a $map$ was chosen to be $\ldata ... \rdata$ as a $map$ is a collection of injections
such that if $M$ is the result of $associate(base, x_{i}, y_{i})$ from above then
$$atKey(M, x_{i}) = y_{i} \iff x_{i} \mapsto y_{i} ~\land (x_{i}, y_{i}) \in M$$

\subsection{Select Operations}
The follow are defined in Chpater 4 (The Mathematical Tool-kit) within the reference manual
and are used extensively throughout this document. In many cases, the functions listed here
will serve as Operations in the context of Primitives and Algorithms.

\subsubsection{Functions}

\subsubsection{Ordered Pairs, Mapping and Composition of Relations}
\begin{argue}
  first & returns the first element of an ordered pair, page 93 \\
  second & returns the second element of an ordered pair, page 93 \\
  \mapsto & maplet is a graphic way of expressing an ordered pair, page 95 \\
  \comp & The composition of two relationships, page 97 \\
  \circ & The backward composition of two relationships, page 97
\end{argue}

\begin{gendef}[X,Y]
  first: X \cross Y \fun X \\
  second: X \cross Y \fun Y
  \where
  \forall x: X; y: Y @ \\
  \t1 first(x,y) = x \ \land \\
  \t1 second(x,y) = y
\end{gendef}

\begin{gendef}[X,Y]
  \_\mapsto\_: X \cross Y \fun X \cross Y
  \where
  \forall x:X; y:Y @ \\
  x \mapsto y = (x, y)
\end{gendef}

\begin{gendef}[X,Y,Z]
  \_\comp\_: (X \rel Y) \cross (Y \rel Z) \fun (X \rel Z) \\
  \_\circ\_: (Y \rel X) \cross (X \rel Y) \fun (X \rel X)
  \where
  \forall ~Q : X \rel Y; R : Y \rel Z @ \\
  \t1 Q \comp R = R \circ Q = \{~x : X; y : Y; z : Z | \\
  \t5  x ~\underline{Q} ~y \ \land \ y ~\underline{R} ~z @ x \mapsto z\}
\end{gendef}

\end{document}
