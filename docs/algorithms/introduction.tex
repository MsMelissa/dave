\documentclass[../main.tex]{subfiles}

\begin{document}

\section{Operations, Primitives and Algorithms}
The following sections introduce, define and explain Operations, Primitives and Algorithms generally using the Terminology presented below. Operations are the building blocks of Primitives whereas Primitives are the building blocks of Algorithms. The definitions which follow are flexible enough to support implementation across programing languages but have been inspired by the core concepts found within Lisp and Z. The focus of these sections is to define the properties of and interactions between Operations, Primitives and Algorithms in a general way which doesn't place unnecessary bounds on their range of possible functionality with respect to processing xAPI data.

\subsection{Terminology}

Within this document, (s) indicates one or more.
When talking about some $x \in X$ at some index within a range $i~..~n~..~j$, the notation $i_{X} ~\lor ~n_{X}, ~\lor ~j_{X}$ may be used in cases where it is a more concise version of an equivalant expression.

\subsubsection{Scalar}
When working with xAPI data, Statements are written using \href{https://www.json.org/}{JavaScript Object Notation} (JSON).
This data model supports a few fundamental types as described by \href{https://json-schema.org/understanding-json-schema/reference/type.html}{JSON Schema}.
In order to speak about a singular valid JSON value (string, number, boolean, null) generically, the term Scalar is used.
To talk about a scalar within a Z Schema, the following free and basic types are introduced.
\begin{zed}
  [STRING, NULL] \\
  Boolean :== true ~| ~false \\
  Scalar :== Boolean ~| ~STRING ~| ~NULL ~| ~\num
\end{zed}
Arrays and Objects are also valid JSON values but will be referenced using the terms Collection and Map $\lor$ KV respectively.

\subsubsection{Collection}
a sequence $\langle ... \rangle$ of items $c$ such that each $c : \nat \cross V \implies (\nat, V) \implies \nat \mapsto V$
\begin{axdef}
  C : Collection
  \where
  C = \langle c_{i}..c_{n}..c_{j} \rangle \implies \{~i \mapsto c_{i}, n \mapsto c_{n}, j \mapsto c_{j} \} @
  i \leq n \leq j \implies i \prec n \prec j \iff i \not= n \not= j
\end{axdef}
And the following free type is introducted for collections
\begin{argue}
  Collection :== emptyColl ~| ~append \ldata Collection \cross Scalar ~\lor Collection ~\lor KV \cross \nat \rdata \\
  \t1 emptyColl & the empty Collection $\langle  \rangle$ \\
  \t1 append & is a constructor and is infered to be an injection \\
  \t1 KV & a free type introduced bellow \\
  append(emptyColl, c?, 0) = \langle c_{0} \rangle \implies \{~0 \mapsto c?\} & $append$ adds $c?$ to $\langle  \rangle$ at $\nat$
\end{argue}

\subsubsection{Key}

An identifier $k$ paired with some value $v$ to create an ordered pair $(k, v)$. $k$ can take on any valid JSON value (Scalar, Collection, KV)
except for the Scalar null. The following free type is introduced for keys.
\begin{zed}
  K ::= (Scalar \hide NULL) ~| ~Collection ~| ~KV
\end{zed}

\subsubsection{Value}

A value $v$ is paired with an identifier $k$ to create an ordered pair $(k, v)$. $v$ can be any valid JSON value (Scalar, Collection, KV)
The following free type is introduced for values.

\begin{zed}
  V ::= Scalar ~| ~Collection ~| ~KV
\end{zed}

\subsubsection{Map}
Within the Z Notation Introduction section, Maps are introduced using the free type $KV$.
\begin{zed}
  KV ::= base ~| ~associate \ldata~KV \cross X \cross Y \rdata
\end{zed}
This definition is more accurately
\begin{zed}
  KV ::= base ~| ~associate \ldata~KV \cross K \cross V \rdata
\end{zed}
which indicates the usage of Key $k$ and Value $v$ within $associate$. Using this updated definition,
\begin{zed}
  associate(base, k, v) = \ldata (k, v) \rdata
\end{zed}
such that a Map is a Collection of ordered pairs $(k_{n}, v_{n})$ and thus a Collection of mappings
\begin{zed}
  (k_{n}, v_{n}) \implies k_{n} \mapsto v_{n}
\end{zed}
but Maps are special cases of Collections as $k_{n}$ is the unique identifier of $v_{n}$ within a Map
but the opposite is not true. In fact, keys are their own identifiers
\begin{zed}
  \id v_{n} = k_{n} \\
  \id k_{n} \not= v_{n} \\
  \id k_{n} = k_{n}
\end{zed}
Given a Map $M = \ldata (k_{i}, v_{i})~..~(k_{n}, v_{n})~..~(k_{j}, v_{j}) \rdata$ the following demonstrates the uniqueness of Keys
but the same is not true for all $v$ within $M$
\begin{zed}
  i_{k} \not= n_{k} \not= j_{k} \\
  i_{v} = n_{v} \lor i_{v} \not= n_{v} \
  i_{v} = j_{v} \lor i_{v} \not= j_{v} \
  j_{v} = n_{v} \lor j_{v} \not= n_{v}
\end{zed}
which can all be stated formally as
\begin{gendef}[K, V]
  Map : K \cross V \bij KV
  \where
  Map = \ldata (k_{i}, v_{i})~..~(k_{n}, v_{n})~..~(k_{j}, v_{j}) \rdata @ \\
  \t1 \dom Map = \{~ k_{i}~..~k_{n}~..~k_{j}\} \\
  \t1 \ran Map = \{~v_{i}~..~v_{n}~..~v_{j}\} \\
  \t1 first(k_{i}, v_{i}) \not= first(k_{n}, v_{n}) \not= first (k_{j}, v_{j}) ~\land \\
  \t1 i_{v} = n_{v} \lor i_{v} \not= n_{v} \ i_{v} = j_{v} \lor i_{v} \not= j_{v} \ j_{v} = n_{v} \lor j_{v} \not= n_{v} ~\land \\
  \t1 \id ~v_{i} = k_{i} ~\land \id ~v_{n} = k_{n} ~\land \id ~v_{j} = k_{j} ~\land \\
  \t1 \id ~k_{i} = k_{i} ~\land \id ~k_{n} = k_{n} ~\land \id k_{j} = k_{j}
\end{gendef}
Given that $v$ can be a Map $M$, or a Collection $C$, Arbitrary nesting is allowed within Maps but the properties of a Map hold at any depth.
$$M = \ldata (k_{i}, v_{i})~..~(k_{n}, \ldata (k_{ni}, v_{ni}) \rdata)~..(k_{j}, \langle v_{ji}~..~\ldata (k_{jn}, v_{jn}) \rdata~..~\langle v_{jji}~..~v_{jjn}~..~v_{jjj}\rangle\rangle) \rdata$$
such that $\ldata (k_{ni}, v_{ni}) \rdata$ and $\ldata (k_{nj}, v_{nj}) \rdata$ are both Maps and adhere to the constraints enumerated above.

\subsubsection{Statement}

Immutable Map conforming to the \href{https://github.com/adlnet/xAPI-Spec/blob/master/xAPI-Data.md#24-statement-properties}{xAPI Specification} as described in the xAPI Formal Definition section of this document. The imutability of a Statement $s$ is demonstrated by the following
which indicates that $s$ was not altered when passed to $associate$.
\begin{axdef}
  s!, s? : STATEMENT \\
  k? : K \\
  v? : V \\
  \where
  s! = associate(s?, k?, v?) = s? \implies (k?, v?) \not \in s! \implies s! = s? \\
\end{axdef}
 Additionally, given the schema $Statements$ the following is true for all $Statement$(s)
\begin{axdef}
  Statements \\
  Keys : STRING \\
  S : Collection
  \where
  Keys = \{~id, actor, verb, object, result, context, attachments, timestamp, stored\} \\
  \dom statement = K \dres Keys \\
  S = \langle ~statement_{i}~..~statement_{n}~..~statement_{j} \rangle @ \\
  \t1 atKey(statement_{i}, id) \not= atKey(statement_{n}, id) \not= atKey(statement_{j}, id) \implies \\
  \t1 id_{i} \not= id_{n} \not= id_{j} \iff statement_{i} \not= statement_{n} \not= statement_{j}
\end{axdef}
Which confirms the constraints found in the schema $Statement$ and adds an additional constraint
to $Statements$ such that every unique $Statement$ in a $Collection$ of $Statements$ has a unique $id$.

\subsubsection{Algorithm State}

Mutable Map $state$ without any domain restriction such that
\begin{axdef}
  state?, state! : KV \\
  k? : K \\
  v? : V
  \where
  associate(state?, k?, v?) = state! @ (k, v) \in state! \implies state? \not= state!
\end{axdef}

\subsubsection{Option}

Mutable Map $opt$ which is used to alter the result of an Algorithm. The effect of $opt$ on an Algorithm will be discussed in the Algorithm Result section bellow.

\section{Operation}

An Operation is a function of arbitrary arguments and is defined using Z. For example, Operations pulled directly from "The Z Notation: A Reference Manual" include
\begin{itemize}
\item $first$
\item $second$
\item $succ$
\item $\min$
\item $\max$
\item $count \equiv \#$
\item $\cat$
\item $rev$
\item $head$
\item $last$
\item $tail$
\item $front$
\item $\extract$
\item $\filter$
\item $\dcat$
\item $\disjoint$
\item $\partition$
\item $\otimes$
\item $\uplus$
\item $\uminus$
\item $items$
\end{itemize}

\subsection{Domain}
The arguments passed to an Operation can be any of the following but the definition of an Operation may limit the domain to a subset of the following
\begin{itemize}
\item Key(s)
\item Value(s)
\item Set(s)
\item Collection(s)
\item Bag(s)
\item KV(s)
\item Statement(s)
\item Algorithm State
\end{itemize}

\subsection{Range}
The result of an Operation can be any of the following but the definition of an Operation may limit this range to a subset of the following

\begin{itemize}
\item Key(s)
\item Value(s)
\item Set(s)
\item Collection(s)
\item Bag(s)
\item KV(s)
\item Statement(s)
\item Algorithm State
\end{itemize}

\section{Primitive}
A collection of Operations where the output of an Operation $o$ is passed as an argument to the next Operation.
\begin{zed}
  p_{\langle i~..~n~..~j \rangle} = o_{i} ~\pipe ~o_{n} ~\pipe ~o_{j}
\end{zed}
Within any given Primitive $p$, variables local to $p$ and any global variables may be passed as arguments to any $o$ within $p$ and there is no restriction on the ordering of arguments with respect to the piping. In the following, $q?$ is a global variable where as the rest are local.
\begin{axdef}
  x?, y?, z?, i!, n!, j!, p! : Value \\
  o_{i} : Value \fun Value \\
  o_{n} : Value \cross Value \fun Value \\
  o_{j}, p : Value \cross Value \cross Value \fun Value \\
  \where
  i! = o_{i}(x?) \\
  n! = o_{n}(i!, y?) \\
  j! = o_{j}(z?, n!, q?) \\
  p! = j! \implies o_{j}(z?, o_{n}(o_{i}(x?), y?), q?)
\end{axdef}
Primitives break the processing of xAPI data down into discrete units that can be composed to create new analytical functions. Primitives allow users to address the methodology of answering research questions as a sequence of generic algorithmic steps which establish the necessary data transformations, aggregations and calculations required to reach the solution in an implementation agnostic way.

\subsection{Domain}
Any of the following dependent upon the Operations which compose the Primitive

\begin{itemize}
\item Key(s)
\item Value(s)
\item Set(s)
\item Collection(s)
\item Bag(s)
\item KV(s)
\item Statement(s)
\item Algorithm State
\end{itemize}

\subsection{Range}
Any of the following dependent upon the Domain and Functionality of the Primitive

\begin{itemize}
\item Key(s)
\item Value(s)
\item Set(s)
\item Collection(s)
\item Bag(s)
\item KV(s)
\item Statement(s)
\item Algorithm State
\end{itemize}

\section{Algorithm}
Given a Collection of statement(s) $S_{\langle a..b..c \rangle}$ and potentially option(s) $opt$ and potentially an existing Algorithm State $state$ an Algorithm $A$ executes as follows

\begin{enumerate}
\item call $init$
\item for each $stmt \in S_{\langle a..b..c \rangle}$
  \begin{enumerate}
  \item $relevant?$
  \item $accept?$
  \item $step$
  \end{enumerate}
\item return $result$
\end{enumerate}
with each process within $A$ is enumerated as

\begin{lstlisting}[frame=single]
  (init [state] body)
   - init state

  (relevant? [state statement] body)
   - is the statement valid for use in algorithm?

  (accept? [state statement] body)
   - can the algorithm consider the current statement?

  (step [state statement] body)
   - processing per statement
   - can result in a modified state

  (result [state] body)
   - return without option(s) provided
   - possibly sets default option(s)

  (result [state opt] body)
   - return with consideration to option(s)
\end{lstlisting}
\begin{itemize}
\item $body$ is a collection of Primitive(s) which establishes the processing of inputs $\to$ outputs
\item $state$ is a mutable Map of type $KV$ and synonymous with Algorithm State
\item $statement$ is a single statement within the collection of statements passed as input data to the Algorithm $A$
\item $opt$ are additional arguments passed to the algorithm $A$ which impact the return value of the algorithm and synonymous with Option
\end{itemize}
Such that the execution of A can be described as
\begin{zed}
  Algorithm ::= Init \semi Relevant? \semi Accept? \semi Step \semi Result
\end{zed}
\subsection{Domain}
An Algorithm must be passed an Algorithm State and a Collection of Statement(s). Option is optional.
\begin{itemize}
\item Statement(s)
\item Algorithm State
\item Option(s)
\end{itemize}

\subsection{Range}
An Algorithm will return an Algorithm State.
\begin{itemize}
\item Algorithm State
\end{itemize}

\subsection{Initialization}

First process to run within an Algorithm which returns the Algorithm State for the current iteration.

\begin{schema}{Init[KV]}
  state?, state! : KV \\
  init: KV \fun KV
  \where
  state! = init(state?) @ state! = state? ~\lor ~state! \not = state?
\end{schema}
such that some $state!$ does not need to be related to its arguments $state?$
but $state!$ could be derived from some seed $state?$.
This functionality is dependent upon the $body$ of an Algorithms $init$

\subsubsection{Domain}

\begin{itemize}
\item Algorithm State
\end{itemize}

\subsubsection{Range}

\begin{itemize}
\item Algorithm State
\end{itemize}

\subsection{Relevant?}

First process that each $stmt$ passes through $\implies relevant? \prec accept? \prec step$
\begin{schema}{Relevant?[KV, STATEMENT]}
  state? : KV \\
  stmt? : STATEMENT \\
  relevant? : KV \cross STATEMENT \fun Boolean
  \where
  relevant?(state?, stmt?) = true ~\lor false
\end{schema}
resulting in an indication of whether the $stmt$ is valid within algorithm $A$.
The criteria which determines validity of $stmt$ within $A$ is defined by the $body$ of $relevant?$

\subsubsection{Domain}

\begin{itemize}
\item Statement
\item Algorithm State
\end{itemize}

\subsubsection{Range}

\begin{itemize}
\item Boolean
\end{itemize}

\subsection{Accept?}

Second process that each $stmt$ passes through $\implies relevant? \prec accept? \prec step$
\begin{schema}{Accept?[KV, STATEMENT]}
  state? : KV \\
  stmt? : STATEMENT \\
  accept? : KV \cross STATEMENT \fun Boolean
  \where
  accept?(state?, stmt?) = true ~\lor false
\end{schema}
resulting in an indication of whether the $stmt$ can be sent to $step$ given the current $state$.
The criteria which determines usability of $stmt$ given $state$ is defined by the $body$ of $accept?$


\subsubsection{Domain}

\begin{itemize}
\item Statement
\item Algorithm State
\end{itemize}

\subsubsection{Range}

\begin{itemize}
\item Scalar
\end{itemize}

\subsection{Step}

An Algorithm Step consists of a sequential composition of Primitive(s) and therefore sequential composition of all Operation(s)
where the output of a Primitive is passed as an argument to the next Primitive.
$$p_{i} ~\pipe ~p_{n} ~\pipe ~p_{j} \implies o_{ii} ~\pipe ~o_{in} ~\pipe ~o_{ij} ~\pipe ~o_{ni} ~\pipe ~o_{nn} ~\pipe ~o_{nj} ~\pipe ~o_{ji} ~\pipe ~o_{jn} ~\pipe ~o_{jj}$$
The selection and ordering of Operation(s) and Primitive(s) into an Algorithmic Step determines how the Algorithm State changes during iteration through Statement(s) passed as input to the Algorithm.
\begin{axdef}
  P = \langle p_{i}~..~p_{n}~..~p_{j} \rangle @ i \leq n \leq j \implies i \prec n \prec j \iff i \not= n \not= j @ p_{i} ~\pipe ~p_{n} ~\pipe ~p_{j} \\
  P' = \langle p_{i'}~..~p_{n'}~..~p_{j'} \rangle @ i' \leq n' \leq j' \implies i' \prec n' \prec j' \iff i' \not= n' \not= j' @ p_{i'} ~\pipe ~p_{n'} ~\pipe ~p_{j'} \\
  P'' = \langle p_{x}~..~p_{y}~..~p_{z}\rangle @ x \leq y \leq z \implies x \prec y \prec z \iff x \not= y \not= z @ p_{x} ~\pipe ~p_{y} ~\pipe ~p_{z}
  \where
  P = P' \iff i \mapsto i' ~\land ~n \mapsto n' ~\land ~j \mapsto j' \\
  P = P'' \iff (i \mapsto x ~\land n \mapsto y ~\land j \mapsto z) ~\land (p_{i} \equiv p_{x} ~\land p_{n} \equiv p_{y} ~\land p_{j} \equiv p_{z})
\end{axdef}
$step$ may or may not update the input Algorithm State given the current Statement from the Collection of Statement(s).
\begin{axdef}
  S : Collection \\
  stmt_{a}, stmt_{b}, stmt_{c} : STATEMENT \\
  state?, step_{a}!, step_{b}!, step_{c}! : KV \\
  step : KV \cross STATEMENT \fun KV
  \where
  S = \langle stmt_{a}..stmt_{b}..stmt_{c} \rangle @ a \leq b \leq c \implies a \prec b \prec c \iff a \not= b \not= c \\
  step_{a}! = step(state?, stmt_{a}) @ step_{a}! = state? ~\lor ~step_{a}! \not= state? \\
  step_{b}! = step(step_{a}!, stmt_{b}) @ step_{b}! = step_{a}! ~\lor ~step_{b}! \not= step_{a}! \\
  step_{c}! = step(step_{b}!, stmt_{c}) @ step_{c}! = step_{b}! ~\lor ~step_{c}! \not= step_{b}!
\end{axdef}
In general, this allows $step$ to be defined as
\begin{schema}{Step[KV, STATEMENT]}
  state?, state! : KV \\
  stmt? : STATEMENT \\
  step : KV \cross STATEMENT \fun KV
  \where
  state! = step~(state?, stmt?) = state? ~\lor \not= state?
\end{schema}
A change of $state? \to state! @ state! \not= state?$ can be predicted to occur given
\begin{itemize}
\item The definition of individual Operations which constitute a Primitive
\item The ordering of Operations within a Primitive
\item The Primitive(s) $p$ chosen for inclusion within $P_{\langle i~..~n~..~j \rangle}$
\item The ordering of $p \in P_{\langle i~..~n~..~j \rangle}$ which implies the ordering of $o \in p_{\langle i~..~n~..~j \rangle} \in P_{\langle ii~..~ij~..~ni~..~nj~..~ji~..~jj \rangle}$
\item The key value pair(s) $(K, V) \in stmt$
\item The ordering of Statement(s) $stmt \in S_{\langle a~..~b~..~c \rangle}$
\end{itemize}

\subsubsection{Domain}

\begin{itemize}
\item Statement
\item Algorithm State
\end{itemize}

\subsubsection{Range}

\begin{itemize}
\item Algorithm State
\end{itemize}

\subsection{Result}

Last process to run within an Algorithm which returns the Algorithm State $state$
when all $s \in S$ have been processed by $step$

\begin{zed}
  relevant? \prec accept? \prec step \prec result \prec relevant? \iff S \not= \emptyset \\
  relevant? \prec accept? \prec step \prec result \iff S = \emptyset
\end{zed}
and does so without preventing subsequent calls of $A$
\begin{schema}{result[KV, KV]}
  result!, state?, opt? : KV \\
  result : KV \cross KV \fun KV
  \where
  result! = result(state?, opt?) = state? ~\lor \not = state?
\end{schema}
such that if at some future point $j$ within the timeline $i~..~n~..~j$
\begin{argue}
  S(t_{n}) = \emptyset & S is empty at $t_{n}$ \\
  S(t_{j}) \not= \emptyset & S is not empty at $t_{j}$ \\
  S(t_{n - i}) & stmts(s) added to $S$ between $t_{i}$  and $t_{n}$ \\
  S(t_{j - n}) & stmts(s) added to $S$ between $t_{n}$  and $t_{j}$ \\
  S(t_{j - i}) = S(t_{n - i}) \ \cup \ S(t_{j - n}) & stmts(s) added to $S$ between $t_{i}$ and $t_{j}$
\end{argue}
Algorithm $A$ can pick up from a previous $state_{n}$ without losing track of its own history.
\begin{axdef}
  state_{n-i} = A(state_{i},\ S(t_{n - i})) \\
  state_{n-1} = A(state_{n-2}, \ S(t_{n - 1})) \\
  state_{n} = A(state_{n-1},\ S(t_{n})) \\
  state_{j-n} = A(state_{n}, \ S(t_{j-n})) \\
  state_{j} = A(state_{i},\ S(t_{j - i}))
  \where
  state_{n} = state_{n-1} \iff S(t_{n}) = \emptyset ~\land S(t_{n-1}) \not = \emptyset \\
  state_{j} = state_{j-n} \iff state_{n-i} = state_{n} = state_{n-1}
\end{axdef}
Which makes $A$ capable of taking in some $S_{\langle i..n..j..\infty \rangle}$ as not all $s \in S_{\langle i..\infty \rangle}$ have to be considered at once. In other words, the input data does not need to persist across the history of $A$, only the effect of $s$ on $state$ must be persisted.
Additionally, the effect of $opt$ is determined by the $body$ within $result$ such that
\begin{zed}
  A(state_{n}, \ S(t_{j-n}), \ opt) \\
  \t1 \equiv A(state_{i}\ S(t_{j - i})) \\
  \t1 \equiv A(state_{i},\ S(t_{j - i}), \ opt) \\
  \t1 \equiv A(state_{n}, \ S(t_{j-n}))
\end{zed}
implying that the effect of $opt$ doesn't prevent backwards compatibility of $state$.

\subsubsection{Domain}

\begin{itemize}
\item Algorithm State
\item Option(s)
\end{itemize}

\subsubsection{Range}

\begin{itemize}
\item Algorithm State
\end{itemize}

\subsection{Algorithm Formal Definition}
Given the definitions of Algorithm Components presented above, the previous definition of an Algorithm $A$
\begin{zed}
  Algorithm ::= Init \semi Relevant? \semi Accept? \semi Step \semi Result
\end{zed}
can be refined using the helper function $recur$
\begin{schema}{recur[KV, Collection]}
  state?, state! : KV \\
  S?, S! : Collection \\
  recur! : (KV, COllection) \\
  recur : KV \cross Collection \fun KV \cross Collection
  \where
  recur! = recur(state?, S?) \implies (state!, S!) @ \\
  \t1 state? = state! ~\land ~S! = tail(S?)
\end{schema}
to illustrate how an Algorithm processes a Collection of Statement(s)
\begin{schema}{Algorithm[KV, Collection]}
  Init[KV] \\
  Relevant?[KV, STATEMENT] \\
  Accept?[KV, STATEMENT] \\
  Step[KV, STATEMENT] \\
  result[KV, KV] \\
  recur[KV, Collection] \\
  opt?, state?, state_{s}!, state_{S}! : KV \\
  S? : Collection @ \forall s? \in S? ~| ~s? : STATEMENT \\
  algorithmIter : KV \cross Collection \cross KV \fun KV \cross Collection \\
  algorithm : KV \cross Collection \cross KV \fun KV
  \where
  state_{s}! = algorithmIter(state?, S?, opt?) @ \\
  \t1 let \ \ ~ s_{current} == head(S?) \\
  \t2 init! == init(state?) \\
  \t2 relevant! == relevant?(init!, s_{current}) \\
  \t2 passon_{relevant}? == recur(init!, S?) \iff relevant! = false \\
  \t2 accept! == accept?(init!, s_{current}) \iff relevant! = true \\
  \t2 passon_{accept}? == recur(init!, S?) \iff accept! = false \\
  \t2 step! == step(init!, s_{current}) \iff accept! = true \\
  \t2 passon_{step}? == recur(step!, S?) \iff tail(S?) \not = \emptyset \\
  \t2 result! == result(step!, opt?) \iff tail(S?) = \emptyset\\
  \t2 passon_{result}? == recur(result!, S?) \\
  \t2 passon_{s}? == passon_{relevant}? \iff relevant! = false ~\lor \\
  \t4 \ \ \ \ ~~~passon_{accept}? \iff accept! = false ~\lor \\
  \t4 \ \ \ \ ~~~passon_{step}? \iff relevant! = true ~\land ~ accept! = true ~\land ~tail(S?) \not = \emptyset \\
  \t4 \ \ \ \ ~~~passon_{result}? \iff relevant! = true ~\land ~ accept! = true ~\land ~tail(S?) = \emptyset \\
  \t4 \ \ \ \ \ \  ~~\implies ~ = init! ~\comp ~relevant! ~\lor \\
  \t5 \ \ \ \ ~ = init! ~\comp ~relevant! ~\comp ~accept! ~\lor \\
  \t5 \ \ \ \ ~ = init! ~\comp ~relevant! ~\comp ~accept! ~\comp ~step! ~\lor \\
  \t5 \ \ \ \ ~ = init! ~\comp ~relevant! ~\comp ~accept! ~\comp ~step! ~\comp ~result! \\
  \t1 \ \ \ ~ = passon_{s}? \implies (first(passon_{relevant}? ~\lor ~ passon_{accept}? ~\lor ~passon_{step} ~\lor passon_{result}), tail(S?)) \\
  state_{S}! = algorithm(state?, S?, opt?) \\
  \t1 \ \ \ ~ = first(algorithmIter(state?, S?, opt?) \bsup \# S? \esup) @ \\
  \t3 \forall ~s? \in S? ~\exists_1 ~passon_{s} : KV \cross Collection @ \\
  \t4 passon_{s} = algorithmIter(state?, S?, opt?) @ \\
  \t5 let ~(state_{s} == first(passon_{s})) @ \\
  \t5 \ \ ~~passon_{s'} = algorithmIter(state_{s}, tail(S?), opt?) \implies (state_{s'}, tail(tail(S?))) \\
  \t5 \ \ ~~passon_{s''} = algorithmIter(first(passon_{s'}), second(passon_{s'}), opt?)\\
\end{schema}
The above introduces $algorithmIter$ to describe the processing per $s \in S$ which results in $algorithm$
being an iteration of $algorithmIter$ over $S$. This means there is a
$passon_{s}$ for all $s \in S$ and the result of $algorithm(state, S, opt)$ is
$$first(algorithmIter(state, S, opt) \bsup \# S \esup) \implies first(passon_{result}) \iff second(passon_{result}) = \emptyset$$
\end{document}
