%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:

\documentclass{article}

\usepackage[ruled]{algorithm2e}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{zed-csp}
\usepackage{breqn}
\usepackage{listings}
\lstset{literate = {-}{-}1} % get dashs to show up

\begin{document}
\section*{Question Name}
intro text for the question

\section{Ideal Statements}
paragraph or list describing the ideal input statements

\subsection{statement parameters to utilize}

\begin{itemize}
  \item first param
  \item second param
  \item third param
  \end{itemize}

\section{TLA Statement problems}
paragraph talking about known data issues within current TLA implementation

\section{Algorithm}

\subsection{Summary}
\begin{enumerate}
  \item step 1
  \item step 2
  \item step 3
  \end{enumerate}

  \subsection{Query an LRS via REST}
  How to query an LRS via a GET request to the Statements Resource
  \footnote{\label{moreLink} S is the set of all statements parsed from the statements array within the HTTP response to the Curl request. It may be possible that multiple Curl requests are needed to retrieve all query results. If multiple requests are necessary, S is the result of concatenating the result of each request into a single set}
  \begin{lstlisting}[frame=single]
Agent = "agent={"account":
                {"homePage": "https://example.homepage",
                 "name": 123456}}"

Since = "since=2018-07-20T12:08:47Z"

Until = "until=2018-07-21T12:08:47Z"

Base = "https://example.endpoint/statements?"

endpoint = Base + Agent + "&" + Since + "&" + Until

Auth = Hash generated from basic auth

S = curl -X GET -H "Authorization: Auth"
         -H "Content-Type: application/json"
         -H "X-Experience-API-Version: 1.0.3"
         Endpoint
  \end{lstlisting}

\subsection{Z Specifications}
Outline of Z, includes templates and an example of a system used to check staff members in and out of a building
\subsubsection{xAPI Statement(s) Schema}
[Statement]
[Actor]
[Verb]
[Object]
[Result]
[Context]
[Timestamp]
\begin{schema}{Statement}
  s : Statement
  \where
  s = \{Actor, Verb, Object, Timestamp\} \, \lor
  \\ \t1 \{Actor, Verb, Object, Timestamp, Context\} \, \lor
  \\ \t1 \{Actor, Verb, Object, Timestamp, Result\} \, \lor
  \\ \t1 \{Actor, Verb, Object, Timestamp, Result, Context\}
\end{schema}
\begin{itemize}
\item The variable s is of type Statement and consists of an Actor, Verb, Object, Timestamp and optionally Context and Result
\end{itemize}
\begin{schema}{Statements}
  S : Statements
  \where
  S = \{~s : Statement \, | \, S \, \neg \, \emptyset\} \\
\end{schema}
\begin{itemize}
\item The variable S is of type Statements and is a set of objects s, each of type Statement
\item The variable S is a non empty set
\end{itemize}
\subsubsection{Introduce Basic Types}
\begin{paragraph}{Template}
  [Name of variable(s) of type set]
\end{paragraph}
\begin{paragraph}{Example}
  [X]
\end{paragraph}
\subsubsection{Example Schema}
Basic unit of specification, defines state variables, system state, operations, etc.
\begin{paragraph}{Template}
\begin{schema}{Schema Name}
  Variable Declarations
  \where
  Predicate/Invariants
\end{schema}
\end{paragraph}
\begin{paragraph}{Example}
  \begin{schema}{Counter}
  ctx : \nat
  \where
  0 \leq ctr \leq max
\end{schema}
\begin{paragraph}{Variables}
  \begin{schema}{Counter}
    ctx : \nat
    \where
\end{schema}
\begin{itemize}
\item the variable ctx is a natural number
\end{itemize}
\end{paragraph}
\begin{paragraph}{Predicates}
  \begin{schema}{Counter}
  \where
  0 \leq ctr \leq max
\end{schema}
  \begin{itemize}
  \item ctr is greater than or equal to 0
  \item ctr is less than or equal to max
  \end{itemize}
\end{paragraph}
\end{paragraph}

\subsubsection{Initialisation}
The starting conditions
\begin{paragraph}{Template}
\begin{schema}{Init[VarName]}
  NameOfExistingSchema
  \where
  InitStateOfVarsWithinRefSchema
\end{schema}
\end{paragraph}
\begin{paragraph}{Example}
  \begin{schema}{InitCounter}
    Counter
    \where
    ctr = 0
  \end{schema}
  \begin{itemize}
    \item the value of the counter starts at 0
  \end{itemize}
\end{paragraph}

\subsubsection{Operations}
an operation is specified in Z with a predicate relating the state before and after the invocation of that operation
\begin{paragraph}{Template}
  \begin{schema}{OperationName}
    \Delta SchemaName \\
    inputParam? : SomeType \\
    outputParam! : SomeType
    \where
    InvariantPredicate \\
    NewValForVar' = OperationOnInput/OutputParams
  \end{schema}
\end{paragraph}
\begin{paragraph}{Example}
  \begin{schema}{Increment}
    \Delta Counter
    \where
    ctr < max \\
    ctr' = crt + 1
  \end{schema}
  \begin{itemize}
    \item There is an implicit conjunction (logical-and) between successive lines of the predicate
    \end{itemize}
    \begin{schema}{Decrement}
      \Delta Counter \\
      d? : \nat
      \where
      ctr \geq d? \\
      ctr' = ctr - d?
    \end{schema}
    \begin{itemize}
    \item input params suffixed with ?
    \end{itemize}
    \begin{schema}{Display}
      \Xi Counter \\
      c! : \nat
      \where
      c! = ctr
    \end{schema}
    \begin{itemize}
    \item output params suffixed with !
    \item the greek symbol means that the operation cannot change the state of Counter
    \end{itemize}
  \end{paragraph}
  \subsection{Pseudocode}
  \begin{algorithm}[H]
    \SetAlgoLined
    \KwIn{this text}
    \KwResult{how to write algorithm with \LaTeX2e }
    initialization\;
    \While{not at end of this document}{
      read current\;
      \eIf{understand}{
        go to next section\;
        current section becomes this one\;
      }{
        go back to the beginning of current section\;
      }
    }
    \caption{How to write algorithms}
  \end{algorithm}
  \subsection{Result JSON Schema}
  \subsection{Visualization Description}
  description of the associated visualization in english
  \subsection{VEGA example}
  This section will be updated to include a VEGA JSON blob for prototype viz
\end{document}
